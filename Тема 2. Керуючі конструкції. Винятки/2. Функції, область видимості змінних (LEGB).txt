Функції, область видимості змінних (LEGB)


Функції – це спосіб групування коду, який виконує певну задачу. Вони дозволяють групувати код так, щоб його можна було викликати кілька разів у програмі без необхідності його повторного написання. Функції допомагають організувати код, роблять його більш читабельним і полегшують подальшу роботу з кодом.





Створення та виклик функцій

Функція оголошується за допомогою ключового слова def. Після ключового слова вказується ім'я функції, за яким йде пара дужок (), у яких можна вказати імена деяких змінних, та двокрапка : в кінці рядка. Далі слідує блок команд, що складають функцію. На прикладі можна бачити, що насправді це дуже просто:



✂️ Цей код можна запустити!

def say_hello():
		# тіло функції
    print('Привіт, Світ!')

# Кінець функції say_hello()

# виклик функції
say_hello()

# ще один виклик функції
say_hello()



Ми визначили функцію з ім'ям say_hello, використовуючи описаний вище синтаксис. Ця функція не приймає параметрів, тому в дужках не оголошені якісь змінні.





Аргументи функції

Параметри функції – це деякі вхідні дані, які ми можемо передати функції, щоб отримати результат, що відповідає цим даним.



Функції можуть приймати параметри, тобто деякі значення, що передаються в середину функції для того, щоб вона щось зробила з ними. Ці параметри схожі на змінні, за виключенням того, що значення цих змінних вказуються при виклику функції, та під час роботи функції їм вже присвоєні їх значення.



Параметри вказуються в дужках при оголошенні функції та розділяються комами. Аналогічно ми передаємо значення, коли викликаємо функцію.



Зверніть увагу на термінологію: імена, вказані при оголошенні функції, називаються параметрами, тоді як значення, які ви передаєте у функцію при її виклику, – аргументами.



✂️ Цей код можна запустити!

def print_max(a, b):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'дорівнює', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # пряма передача значень

x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



Тут ми визначили функцію з ім'ям print_max, яка використовує два параметри з іменами a та b. Ми знаходимо найбільше число із застосуванням простого оператора if..else та виводимо це число. При першому виклику функції print_max ми напряму передаємо числа як аргументи.



print_max(3, 4)  # пряма передача значень



У другому випадку ми викликаємо функцію зі змінними як аргументи, print_max(x, y) призначає значення аргументу x параметру a, а значення аргументу y – параметру b.



x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



В обох випадках функція print_max працює однаково.





Типізація параметрів функції

В Python, починаючи з версії 3.5, ви можете використовувати "type hints" (підказки типів) для вказівки очікуваних типів параметрів. Це дозволяє коду бути більш зрозумілим та може допомогти у виявленні можливих помилок.



Попередню функцію ми можемо записати тепер наступним чином:



✂️ Цей код можна запустити!

def print_max(a: int, b: int):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'дорівнює', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # пряма передача значень

x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



У цьому прикладі параметри a: int та b: int позначають, що функція print_max очікує два аргументи типу int (цілі числа). Типізація параметрів допоможе нам зробити очікування функції щодо вхідних даних більш явними.



Типізація в Python є опціональною та не впливає на виконання коду в рантаймі (run-time), але вона може бути корисною для розробників. Це дозволяє легше розуміти код, забезпечує кращу підтримку від редакторів коду, а також полегшує виявлення помилок перед виконанням коду.





Повернення результату

У Python немає синтаксичної різниці між функціями і процедурами. По суті, функція вміє повертати деякий результат своєї роботи, а процедура нічого не повертає та результатом її роботи може бути зміна стану вже існуючих змінних. Така форма використання функцій максимально наближена до функцій, з якими ми знайомі з уроків математики.



Повернення результату з функції в Python виконується за допомогою оператора return. Цей оператор завершує виконання функції та "повертає" значення, яке може бути використане в інших частинах програми. Це особливо корисно для отримання результатів обчислень, обробки даних та інших операцій. В Python ви можете явно вказати тип даних, який повертається функцією, використовуючи анотації типів.



Базовий синтаксис для повернення значення з функції виглядає наступним чином:



def my_function() -> ReturnType:
    # виконати дії
    return result



ReturnType вказує на тип даних, який функція має повертати. Це може бути будь-який тип даних, як-от int, float, str, list, dict, або навіть складніші типи, включаючи класи та інтерфейси, що ми побачимо згодом в курсі. Для повернення значення з функції необхідно вказати, що повернути після ключового слова return. Тому result - це значення або змінна, яку функція повертає.



Розглянемо приклад функції, яка сумує два числа та повертає результат:



✂️ Цей код можна запустити!

def add_numbers(num1: int, num2: int) -> int:
    sum = num1 + num2
    return sum

result = add_numbers(5, 10)
print(result)  # Виведе: 15



У цьому прикладі, функція add_numbers приймає два цілих числа num1 та num2 та повертає їх суму. Тип значення який повертає функція вказаний як int.



Приклад функції, що повертає рядок:



✂️ Цей код можна запустити!

def greet(name: str) -> str:
    return f"Привіт, {name}!"

greeting = greet("Олексій")
print(greeting)  # Виведе: Привіт, Олексій!



Тут функція greet приймає рядок name та повертає привітання, також у форматі рядка.



Функція, що повертає булеве значення:



✂️ Цей код можна запустити!

def is_even(num: int) -> bool:
    return num % 2 == 0

check_even = is_even(4)
print(check_even)  # Виведе: True



Функція is_even перевіряє, чи число парне, і повертає результат булеве значення True або False.



Повернення значень з функцій є ключовим аспектом програмування, оскільки це дозволяє функціям не тільки виконувати певні дії, але й комунікувати результатами цих дій з іншими частинами програми.





Принципи змінності об'єктів у Python

У Python всі об'єкти передаються за посиланням, але важливо розуміти різницю між змінними (mutable) та незмінними (immutable) типами даних, адже від цього залежить, як відбувається передача об'єктів та які помилки можуть виникати.



Незмінні типи в Python — це ті, що не можуть бути змінені після їх створення. Це включає типи, як-от цілі числа int, дійсні числа float, рядки str, кортежі tuple.



Коли незмінний об'єкт передається у функцію, фактично передається його копія, і будь-які зміни цього об'єкту в функції не впливають на оригінальний об'єкт.



Розглянемо наступний приклад:



✂️ Цей код можна запустити!

def modify_string(original: str) -> str:
    original = "змінено"
    return original

str_var = "оригінал"
print(modify_string(str_var))  # виведе: змінено
print(str_var)                # виведе: оригінал



У цьому прикладі, навіть після зміни рядка в функції modify_string, оригінальна змінна str_var залишається незмінною.



Змінні типи, як списки list, словники dict, множини set, можуть змінюватися. Коли змінний об'єкт передається у функцію, передається посилання на цей об'єкт, і зміни, зроблені всередині функції, відображаються на оригінальному об'єкті.



Подивимось наступний приклад зі змінними типами:



✂️ Цей код можна запустити!

def modify_list(lst: list) -> None:
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3, 4]



Тут зміни всередині функції modify_list впливають на оригінальний список my_list. Отже, ми передали в функцію modify_list наш список my_list і після виконання функції modify_list(my_list) сам список змінився.



Змінні об'єкти, передані у функції, можуть змінитися несподівано. Це може привести до помилок, особливо якщо ви не очікуєте, що об'єкт буде змінено.



При "копіюванні" змінного об'єкта шляхом простого присвоєння new_list = old_list ви копіюєте посилання, а не сам об'єкт. Це означає, що зміни в одному списку відображатимуться й у іншому. Фактично в середині функції modify_list відбулося присвоювання lst = my_list



Перед тим, як передавати змінні об'єкти, такі як списки або словники у функцію, важливо зважати на те, чи плануєте ви змінювати ці об'єкти в функції. Якщо вам потрібно залишити оригінальний об'єкт без змін, розгляньте можливість створення копії. Бо якщо ви передаєте змінний об'єкт (наприклад, список) у функцію та модифікуєте його всередині функції, оригінальний список теж зміниться.



Використовуйте метод copy() для створення копій змінних об'єктів, якщо не хочете змінювати оригінал.



✂️ Цей код можна запустити!

def modify_list(lst: list) -> None:
    lst = lst.copy()
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3]



Тут список my_list після виконання функції modify_list вже не зазнає змін.





Задача на функцію

Для закріплення отриманих знань, розглянемо наступний приклад. Уявімо, що перед нами стоїть задача: конвертувати кожен символ у рядку в його відповідний код ASCII. Це класична задача, що демонструє взаємодію з рядками в Python та їх обробку.



Спершу вирішимо, де будемо зберігати ці коди. Один з найкращих варіантів - це використання словника dict, оскільки він дозволяє зберігати пари ключ-значення. У нашому випадку, ключем буде символ, а значенням - його код ASCII.

Для отримання числового коду символу ми будемо використовувати вбудовану функцію ord(). Ця функція приймає один символ і повертає його код ASCII. Наприклад, ord('A') повертає 65, оскільки 65 - це код ASCII для символу 'A'.

Рядки в Python - це ітеруємі об'єкти, що означає, що ми можемо пройтися по кожному символу рядка, використовуючи цикл for. Це ідеально підходить для нашої задачі, адже нам потрібно обробити кожен символ окремо.



Для більшої гнучкості та можливості повторного використання коду ми обгорнемо нашу логіку в функцію. Це дасть нам змогу легко використати цей функціонал із різними рядками ще не один раз.



def string_to_codes(string: str) -> dict:
    # Ініціалізація словника для зберігання кодів
    codes = {}  
    # Перебір кожного символу в рядку
    for ch in string:  
        # Перевірка, чи символ вже є в словнику
        if ch not in codes:
            # Додавання пари символ-код в словник  
            codes[ch] = ord(ch)  
    return codes



Ми створюємо пустий словник codes, де будемо зберігати наші пари символ-код. Далі за допомогою циклу for ми ітеруємося по кожному символу ch у вхідному рядку string. В середині циклу перевіряємо кожен символ рядка, чи вже присутній він у словнику? Якщо ні, використовуємо вбудовану функцію ord(ch) для отримання коду ASCII цього символу та додаємо цю пару до словника codes. Після завершення циклу повертаємо словник codes.



Після виклику функції string_to_codes із рядком "Hello world!", отримуємо словник, де кожен унікальний символ рядка відображений на його числовий код ASCII.



✂️ Цей код можна запустити!

result = string_to_codes("Hello world!")
print(result)



Виведення:



{'H': 72, 'e': 101, 'l': 108, 'o': 111, ' ': 32, 'w': 119, 'r': 114, 'd': 100, '!': 33}



Цей приклад показує, як можна об'єднати знання про рядки, словники, цикли та функції для розв'язання конкретних завдань в Python.

Області видимості (LEGB)

Область видимості — це область у програмі (коді), в межах якої ви можете звернутися за ім'ям до вмісту змінної. Ці області видимості діляться на чотири рівні в порядку пошуку імен змінних, та відомі як LEGB-правило:



L - Local (Локальна): Це внутрішній рівень, де ім'я визначено всередині функції або блоку коду.
E - Enclosing (Охоплювана): Це область видимості, яка охоплює локальну область видимості. Якщо функція знаходиться всередині іншої функції, імена, визначені в охоплюваній функції, будуть доступні для внутрішньої функції.
G - Global (Глобальна): Це область видимості на рівні модуля або сценарію. Змінні, визначені на цьому рівні, доступні у всьому модулі.
B - Built-in (Вбудована): Це самий зовнішній рівень, який містить імена, вбудовані в Python. Наприклад розглянуті нами вбудовані функції, len, range тощо.




Local

У Python кожна змінна, оголошена всередині функції, є локальною для цієї функції. Це означає, що локальні змінні існують лише в межах блоку коду, де вони були оголошені, і не доступні за його межами.



✂️ Цей код можна запустити!

x = 50

def func() -> None:
    x = 2
    print('Зміна локального x на', x)  # Зміна локального x на 2

func()
print('Глобальний x як і раніше', x)  # x як і раніше 50



Змінна x, оголошена всередині функції func, є локальною. Коли ми присвоюємо їй значення 2, це не впливає на глобальну змінну x, оголошену поза функцією. Тому, після виклику func(), виведення залишає глобальне значення x (яке дорівнює 50) незмінним.



Останнім викликом функції print ми виводимо значення x, вказане в основному блоці, підтверджуючи таким чином, що воно не змінилося при локальному присвоюванні значення в раніше викликаній функції.



Виведення:



Зміна локального x на 2
Глобальний x як і раніше 50





Enclosing

Охоплювана (Enclosing) область видимості виникає, коли функція визначена всередині іншої функції. Змінні в функції, що охоплює доступні у внутрішній (вкладеній) функції, але не навпаки. Це означає, що внутрішня функція може читати але не змінювати змінні, визначені в функції, що її охоплює.



Розглянемо наступний приклад:



✂️ Цей код можна запустити!

def outer_func():
    enclosing_var = "Я змінна в функції, що охоплює"

    def inner_func():
        print("Всередині вкладеної функції:", enclosing_var)

    inner_func()

outer_func()



Виведення:



Всередині вкладеної функції: Я змінна в функції, що охоплює



Тут enclosing_var є змінною в функції outer_func, що охоплює функцію inner_func. Вона доступна для читання в вкладеній функції inner_func, але не може бути змінена в inner_func без використання ключового слова nonlocal.



Для того, щоб розібратися як змінювати змінні в функції, що охоплює внутрішню функцію, розглянемо приклад:



def func_outer():
    x = 2

    def func_inner():
        nonlocal x
        x = 5

    func_inner()
    return x

result = func_outer()  # 5



Коли ми перебуваємо всередині функції func_inner, змінна x, визначена у першому рядку функції func_outer, знаходиться в enclosing області видимості для неї. Якщо ми захочемо використати саме цю змінну x, ми повинні оголосити її nonlocal x всередині функції func_inner. Це означає, що змінна x, яку вона буде змінювати, є не локальною для func_inner, а знаходиться на більш високому рівні — в нашому випадку, в func_outer. Тому, коли func_inner змінює x на 5, ця зміна відображається на x в func_outer.



Тому результат result дорівнюватиме 5, а не 2, оскільки всередині функції func_outer ми зробили виклик func_inner(), яка змінила x з 2 на 5.





Global

Для того, щоб змінити глобальну змінну всередині функції, необхідно використовувати ключове слово global. Це вказує Python, що змінна не є локальною, а належить до глобальної області видимості. Без застосування зарезервованого слова global неможливо присвоїти значення змінній, визначеній за межами функції.



✂️ Цей код можна запустити!

x = 50

def func():
    global x
    print('x дорівнює', x)  # x дорівнює 50
    x = 2
    print('Змінюємо глобальне значення x на', x)  # Змінюємо глобальне значення x на 2

func()
print('Значення x складає', x)# Значення x складає 2




Виведення:

x дорівнює 50
Змінюємо глобальне значення x на 2
Значення x складає 2



Зарезервоване слово global використовується для того, щоб оголосити, що x – це глобальна змінна, а значить, коли ми присвоюємо значення імені x всередині функції, ця зміна відобразиться на значенні змінної x в основному блоку програми. Використовуючи одне зарезервоване слово global, можна оголосити відразу декілька змінних: global x, y, z.



Використовувати global варто з великою обережністю і не потрібно зловживати такою можливістю.



Розуміння цих основних принципів є важливим для ефективного написання коду та уникнення помилок, пов'язаних із неправильним використанням змінних. Локальні змінні корисні для забезпечення інкапсуляції даних всередині функцій, тоді як глобальні змінні дозволяють зберігати дані, які потрібні на різних етапах виконання програми.

Ключові аргументи функції

Якщо є деяка функція з великою кількістю параметрів, і при її виклику вимагається вказати тільки деякі з них, значення цих параметрів можуть задаватися за їх ім'ям. Це називається ключовими параметрами.



Ключові аргументи в функціях Python — це спосіб передачі аргументів функції, при якому кожному аргументу присвоюється ім'я. Це дозволяє вказувати аргументи у будь-якому порядку під час виклику функції, не дотримуючись порядку, визначеного у її оголошенні. Ключові аргументи роблять код більш читабельним та дозволяють використовувати значення за замовчуванням для деяких аргументів.



Визначимо функцію з ключовими аргументами



✂️ Цей код можна запустити!

def greet(name, message="Привіт"):
    print(f"{message}, {name}!")



У цьому прикладі name — це позиційний параметр, а message — ключовий параметр зі значенням за замовчуванням "Привіт". При виклику функції можна не вказувати message, і тоді буде використано значення за замовчуванням.



# використовує значення за замовчуванням для message
greet("Олексій")  

# передача власного значення для message
greet("Марія", message="Добрий день")  



Виведення:



Привіт, Олексій!
Добрий день, Марія!



У першому виклику ми передаємо тільки name, а у другому — і name, і message.

Розглянемо наступний приклад для демонстрації гнучкості ключових аргументів, та можливості змінювати порядок аргументів або використовувати значення за замовчуванням.



✂️ Цей код можна запустити!

def func(a, b=5, c=10):
    print('a дорівнює', a,', b дорівнює', b,', а c дорівнює', c)

# a дорівнює 3, b дорівнює 7, а c дорівнює 10
func(3, 7)

# a дорівнює 25, b дорівнює 5, а c дорівнює 24
func(25, c=24)

# a дорівнює 100, b дорівнює 5, а c дорівнює 50
func(c=50, a=100)



Виведення:



a дорівнює 3 , b дорівнює 7 , а c дорівнює 10
a дорівнює 25 , b дорівнює 5 , а c дорівнює 24
a дорівнює 100 , b дорівнює 5 , а c дорівнює 50



Функція з ім'ям func має один параметр без значення за замовчуванням, за яким слідують два параметри зі значеннями за замовчуванням. При першому виклику func(3, 7), параметр a отримує значення 3, параметр b отримує значення 7, а c отримує своє значення за замовчуванням, що дорівнює 10.



При другому виклику func(25, c=24) змінна a отримує значення 25 на підставі позиції аргументу. Після цього параметр c отримує значення 24 за ім'ям, тобто як ключовий параметр. Змінна b отримує значення за замовчуванням, що дорівнює 5.



При третьому зверненні func(c=50, a=100) ми використовуємо ключові аргументи для усіх вказаних значень. Зверніть увагу на те, що ми вказуємо значення для параметра c перед значенням для a, навіть попри те, що у визначенні функції параметр a вказаний раніше c.



Ключові аргументи роблять функції більш гнучкими та підвищують читабельність коду, особливо коли функція має багато параметрів або коли деякі параметри мають зрозумілі значення за замовчуванням. Це також дозволяє уникнути помилок, що можуть виникнути через неправильний порядок аргументів при виклику функції.



Функція з ім'ям say використовується для виведення на екран рядка, вказаного число разів.



✂️ Цей код можна запустити!

def say(message, times=1):
    print(message * times)

say('Привіт') 
say('Світ', 5)



Якщо ми не вказуємо значення за замовчуванням, рядок виводиться один раз. Ми досягаємо цього задавши значення аргументу за замовчуванням, що дорівнює 1 для параметра times. При першому виклику say ми вказуємо тільки рядок, і функція виводить його один раз. При другому виклику say ми вказуємо також і аргумент, позначаючи таким чином, що ми хочемо сказати фразу 5 разів.



Значеннями за замовчуванням можуть бути забезпечені тільки параметри, що знаходяться у кінці списку параметрів. Таким чином, у списку параметрів функції параметр зі значенням за замовчуванням не може передувати параметру без значення за замовчуванням. Це пов'язано з тим, що значення надаються параметрам відповідно до їх положення. Наприклад, def func(a, b=5) — допустимо, а def func(a=5, b) – не допустимо та призведе до помилки в коді.



Розглянемо типову задачу, яка відображає реальну ситуацію в області торгівлі та фінансів, де потрібно часто обраховувати ціни зі знижками. Нам необхідно створити функцію для розрахунку вартості товарів з урахуванням можливої знижки.



Для розрахунку реальної ціни з врахуванням дисконту створимо функцію real_cost. Функція real_cost повинна приймати два аргументи: базову ціну товару base та розмір знижки discount, який за замовчуванням будемо вважати 0. Вона повинна повертати вартість товару після застосування знижки.



def real_cost(base: int, discount: float = 0) -> float:
    return base * (1 - discount)



Функція використовує формулу base * (1 - discount) для обрахунку остаточної вартості. Якщо знижка відсутня, то використовується лише базова ціна.



Ціна на хліб price_bread завжди без знижки і вона не застосовується, тому при визові функції real_cost використовується лише базова ціна. Для масла price_butter та цукру price_sugar застосовуємо знижки 5% та 7% відповідно.



price_bread = 15
price_butter = 50
price_sugar = 60

current_price_bread = real_cost(price_bread)
current_price_butter = real_cost(price_butter, 0.05)
current_price_sugar = real_cost(price_sugar, 0.07)



Вивід результатів



print(f'Нова вартість хліба: {current_price_bread}')
print(f'Нова вартість масла: {current_price_butter}')
print(f'Нова вартість цукру: {current_price_sugar}')



Виведення:



Нова вартість хліба: 15
Нова вартість масла: 47.5
Нова вартість цукру: 55.8



Функція real_cost показує, як можна використовувати функції та параметри за замовчуванням для обрахунку цін зі знижками. Це приклад того, як прості програмувальні концепції можуть бути застосовані для вирішення реальних бізнес-задач.

Змінна кількість параметрів

Змінна кількість параметрів у функції в Python дозволяє функції приймати нефіксовану кількість аргументів. Це корисно у ситуаціях, коли ви хочете дозволити передавати різну кількість параметрів у свою функцію.



У Python існує два способи реалізації змінної кількості параметрів.



Параметр *args. Він дозволяє функції приймати довільну кількість позиційних аргументів. Аргументи, передані функції, зберігаються у вигляді кортежу.
Параметр **kwargs. Він дозволяє функції приймати довільну кількість ключових аргументів. Але аргументи, передані функції, зберігаються вже у вигляді словника.




Приклад використання параметру *args

Спочатку розглянемо приклад *args. Параметр *args використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість позиційних аргументів. Це означає, що ви можете передавати в функцію стільки аргументів, скільки потрібно, без необхідності їх попереднього визначення.



✂️ Цей код можна запустити!

def print_all_args(*args):
    for arg in args:
        print(arg)

print_all_args(1, 'hello', True)



Виведення:



1
hello
True



У цьому прикладі, функція print_all_args може приймати будь-яку кількість аргументів. Аргументи 1, 'hello', та True передаються у функцію як кортеж і в середині функції змінна args зберігає кортеж (1, 'hello', True).



Де це може знадобиться? Насправді багато де, але ми розглянемо дуже простий та зрозумілий приклад. Нам треба написати функцію, яка буде передану будь яку кількість рядків об'єднувати в один рядок та повертати його.



✂️ Цей код можна запустити!

def concatenate(*args) -> str:
    result = ""
    for arg in args:
        result += arg
    return result

print(concatenate("Hello", " ", "world", "!"))



Виведення:



Hello world!



У цьому прикладі, функція concatenate може приймати будь-яку кількість рядкових аргументів, які потім конкатенуються в один рядок. Під час виклику функції, всі позиційні аргументи, передані після останнього визначеного аргументу, будуть упаковані в кортеж під ім'ям, що йде після символу * і зазвичай це ім'я args, але може бути будь-яке інше ім'я. Наступний приклад теж працюватиме але загально прийнято називати цей параметр args:



✂️ Цей код можна запустити!

def concatenate(*strings) -> str:
    result = ""
    for arg in strings:
        result += arg
    return result

print(concatenate("Hello", " ", "world", "!"))



Ми замінили назву параметру args на strings і в нас все продовжує працювати.

Отже підіб'ємо короткий підсумок - параметр *args використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість позиційних аргументів. Це означає, що ви можете передавати в функцію стільки аргументів, скільки потрібно, без необхідності їх попереднього визначення.





Приклад використання параметру **kwargs

Параметр **kwargs використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість ключових аргументів. Назва kwargs пішла від "keyword arguments" та дозволяє передавати в функцію іменовані аргументи у вигляді словника.



Під час виклику функції, всі ключові аргументи, передані після останнього визначеного аргументу, будуть упаковані в словник під ім'ям, що йде після ** та зазвичай це kwargs, але, як і випадку args, може бути будь-яке інше ім'я.



✂️ Цей код можна запустити!

def greet(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

greet(name="Alice", age=25)



Виведення:



name: Alice
age: 25



У цьому прикладі, greet може приймати будь-яку кількість ключових аргументів, які потім обробляються і виводяться. В середині функції змінна kwargs зберігає словник, в нашому випадку це {'name': 'Alice', 'age': 25}.



Якщо виникає питання коли використовувати ці параметри, то параметр *args ми використовуємо коли хочемо дозволити передавати функції різну кількість позиційних аргументів. Параметр **kwargs — коли ми хочемо дозволити передавати функції різну кількість ключових аргументів.



Проте ніхто не забороняє параметри *args та **kwargs використовувати разом у функції, що дозволяє їй приймати довільну кількість як позиційних, так і ключових аргументів. Це робить функцію надзвичайно гнучкою. Головне пам'ятати, що коли ви використовуєте обидва ці параметри разом, *args має йти перед **kwargs. Тоді параметр *args збере всі позиційні аргументи в кортеж, а **kwargs збере всі ключові аргументи в словник.



✂️ Цей код можна запустити!

def example_function(*args, **kwargs):
    print("Позиційні аргументи:", args)
    print("Ключові аргументи:", kwargs)

example_function(1, 2, 3, name="Alice", age=25)



Виведення:



Позиційні аргументи: (1, 2, 3)
Ключові аргументи: {'name': 'Alice', 'age': 25}



При виклику example_function аргументи 1, 2, 3 є позиційними, які параметр *args збере в кортеж (1, 2, 3). Аргументи name="Alice" та age=25 є ключовими, які **kwargs збере в словник {'name': 'Alice', 'age': 25}



В майбутньому ви побачите, що ці методи роблять ваші функції значно більш гнучкими та здатними обробляти різні сценарії виклику. Використання *args та **kwargs разом надзвичайно корисне в ситуаціях, де вам буде потрібно передати різноманітні аргументи в функцію, особливо коли ви почнете писати API, декоратори або обгортки навколо інших функцій і ви не зможете передбачити, як саме інші розробники будуть використовувати ваші функції.



❗ Завжди використовуйте *args перед **kwargs у визначенні функції, оскільки це обов'язкове правило синтаксису Python.




Розпакування списків та словників

Давайте розглянемо можливості операторів * та **. Їх використовують для розпаковки списків та словників. Розпакування списків та словників в Python — це потужна можливість, яка дозволяє присвоїти значення зі списку або словника до змінних одним рядком коду. Ця функція значно спрощує роботу з колекціями даних.



Розпакування списку дозволяє присвоїти елементи списку окремим змінним. Наприклад:



my_list = [1, 2, 3]
a, b, c = my_list



Тут a отримає значення 1, b отримає 2, і c отримає 3.

Якщо вам потрібно ігнорувати деякі з елементів списку під час розпакування, можна використовувати _:



a, _, c = my_list



У цьому прикладі a отримає 1, другий елемент списку буде ігноровано, і c отримає 3.



Можна також розпакувати частину списку, використовуючи *:



a, *rest = my_list



Тут a отримає перший елемент списку 1, а rest стане списком, що містить всі інші елементи та дорівнюватиме [2, 3].



Розпакування списків корисне, коли вам потрібно швидко присвоїти значення зі списку змінним або коли вам потрібно ігнорувати деякі з цих значень.

Розпакування словників працює трохи інакше і зазвичай використовується під час передачі аргументів у функцію.



def greet(name, age):
    print(f"Hello {name}, you are {age} years old.")

person_info = {"name": "Alice", "age": 25}
greet(**person_info)



У цьому прикладі **person_info розпаковує словник person_info, і його ключі та значення передаються як ключові аргументи в функцію greet.



Розпакування словників часто використовується для передачі іменованих аргументів у функції, особливо коли кількість аргументів або їхні імена не відомі заздалегідь.

Рекурсія

Рекурсія — це концепція в програмуванні, коли функція викликає саму себе в рамках власного виконання. Це схоже на дроблення великої проблеми на менші, керованіші проблеми.



Розглянемо декілька простих прикладів рекурсивних функцій, таких як обчислення факторіала числа або чисел Фібоначчі.



Але спочатку нам треба визначити основні компоненти рекурсії:



Базовий випадок: Це умова, при якій рекурсія припиняє виклик самої себе, щоб уникнути нескінченного циклу. Він важливий для запобігання нескінченному циклу в рекурсії.
Рекурсивний випадок: Це умова, за якої функція викликає саму себе з новими аргументами. Фактично це ситуація, коли функція продовжує викликати саму себе, розбиваючи проблему на менші частини


Давайте розглянемо це на прикладі рекурсивної функції, яка обчислює факторіал числа.



Факторіал натурального числа 
𝑛
n (позначається як 
𝑛
!
n!) — це добуток всіх натуральних чисел від 1 до 
𝑛
n включно.



Математичне визначення факторіала виглядає так:



𝑛
!
=
{
1
 якщо 
𝑛
=
0
𝑛
×
(
𝑛
−
1
)
!
 якщо 
𝑛
>
0
n!={ 
1
n×(n−1)!
​
  
 якщо n=0
 якщо n>0
​
 



На основі цього визначення можна легко створити рекурсивну функцію для обчислення факторіала:



✂️ Цей код можна запустити!

def factorial(n):
    if n == 0: # базовий випадок
        return 1
    else:
        return n * factorial(n-1) # рекурсивний випадок

print(factorial(5)) # виведе 120



У цьому прикладі:



Базовий випадок: якщо n дорівнює 0, повернути 1. Це припиняє рекурсію, оскільки не відбувається додатковий виклик функції factorial.
Рекурсивний випадок: якщо n не дорівнює 0, повернути **n,**помножену на factorial(n-1). Ось тут і відбувається виклик функції factorial з аргументом, який на одиницю менший від поточного n, тому це є рекурсивний випадок.


Цей код працює тому, що кожен виклик factorial(n-1) працює на дедалі меншому числі аж до того моменту, коли n дорівнює 0, і відбувається базовий випадок. На цьому етапі рекурсія завершується, і результат починає "повертатися" назад через усі попередні виклики функції, обчислюючи добуток на кожному кроці.



Числа Фібоначчі — це послідовність чисел, у якій кожне наступне число є сумою двох попередніх. Перші два числа в цій послідовності, за визначенням, дорівнюють 0 і 1.



Математична формула для числа Фібоначчі:



𝐹
(
𝑛
)
=
{
0
 якщо 
𝑛
=
0
1
 якщо 
𝑛
=
1
𝐹
(
𝑛
−
1
)
+
𝐹
(
𝑛
−
2
)
 якщо 
𝑛
>
1
F(n)= 
⎩
⎨
⎧
​
  
0
1
F(n−1)+F(n−2)
​
  
 якщо n=0
 якщо n=1
 якщо n>1
​
 



Рекурсивний підхід до обчислення чисел Фібоначчі базується на прямому застосуванні цього визначення. Ось як його можна реалізувати:



✂️ Цей код можна запустити!

def fibonacci(n):
    if n <= 1: # базовий випадок
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2) # рекурсивний випадок

print(fibonacci(10)) # виведе 55



Базовий випадок. Якщо 
𝑛
≤
1
n≤1, функція просто повертає 
𝑛
n. Це відповідає визначенню перших двох чисел Фібоначчі: 
𝐹
(
0
)
=
0
F(0)=0 та 
𝐹
(
1
)
=
1
F(1)=1.
Рекурсивний випадок. Якщо 
𝑛
>
1
n>1, функція повертає суму двох попередніх чисел Фібоначчі, обчислених за допомогою рекурсивних викликів: 
𝐹
(
𝑛
−
1
)
F(n−1) та 
𝐹
(
𝑛
−
2
)
F(n−2).


Тут основна ідея в тому, що кожне число Фібоначчі є сумою двох попередніх чисел Фібоначчі (за винятком перших двох чисел). Тому щоб отримати $n$-е число Фібоначчі, вам потрібно додати 
(
𝑛
−
1
)
(n−1) та 
(
𝑛
−
2
)
(n−2) числа Фібоначчі. І цей процес продовжується рекурсивно, доки ви не дійдете до базового випадку.



Але що буде, якщо функція не матиме базового випадку і не повертатиме ніякого результату? Однією з потенційних проблем при використанні рекурсії є переповнення стеку. Якщо рекурсивні виклики функції продовжуються без досягнення базового випадку, стек викликів може переповнитись, що призведе до помилки виконання. Така помилка називається переповненням стеку (stack overflow, саме на її честь було названо популярний сайт https://stackoverflow.com). Багаторазові виклики функцій без повернення збільшують стек викликів доти, доки не буде витрачено всю виділену йому пам'ять комп'ютера.



Щоб цьому запобігти, інтерпретатори примусово завершують роботу програми після досягнення ліміту викликів функцій, які не повертають результат. Така межа називається максимальною глибиною рекурсії, або максимальним розміром стеку викликів. У Python граничним значенням вважається 1000 викликів функцій.





Стек викликів рекурсії

Коли йдеться про рекурсію, ми зазвичай говоримо про функцію, яка викликає саму себе. Проте щоб краще зрозуміти, як рекурсія функціонує, потрібно зрозуміти, як комп'ютер обробляє виклики функцій взагалі. Тут ми стикаємося з поняттям "стек викликів".



Стек викликів — це специфічна частина пам'яті, яка використовується для зберігання інформації про активні виклики функцій. Кожен раз, коли функція викликається, створюється новий запис (або "шар") у цьому стеку для цього конкретного виклику. Цей шар містить інформацію про змінні функції, її параметри та місце, звідки була викликана функція, щоб після завершення виконання функції програма могла продовжити роботу з правильного місця.



Тож коли функція викликає себе рекурсивно, кожен новий виклик функції зберігається в стеку викликів. Сам стек викликів створює інтерпретатор Python під час виконання програми.



Якщо уявити стек як стопку книг, де кожна нова книга, яку ви кладете зверху, відображає новий виклик функції, то рекурсія — це додавання нових книг на верх стосу. Коли функція завершує свою роботу, "книга" знімається зі стосу, і ми "повертаємося" до попередньої книги.



Отже, коли базовий випадок досягнуто, виклики функцій починають "розвантажуватись" зі стеку, що дозволяє розрахувати кінцевий результат.

Розглянемо приклад коду, який показує, як працює стек викликів у рекурсії на прикладі функції для обчислення факторіала числа:



✂️ Цей код можна запустити!

def factorial(n):
    print("Виклик функції factorial з n = ", n)
    if n == 1:
        print("Базовий випадок, n = 1, повернення 1")
        return 1
    else:
        result = n * factorial(n-1)
        print("Повернення результату для n = ", n, ": ", result)
        return result

print(factorial(5))



Цей код обчислює факторіал числа 5, який дорівнює 5 * 4 * 3 * 2 * 1 = 120. Коли ви запустите цей код, ви побачите послідовність викликів рекурсивної функції і повернення результатів.



💡 Скопіюйте код і запустіть самостійно, щоб наочно подивитись, як він працює.


Цей приклад показує, як кожен виклик рекурсивної функції додає новий "шар" у стек викликів, а кожен повернений результат видаляє "шар". Базовий випадок (тут це n == 1) дозволяє завершити рекурсію і почати повертати результати.



Виконаємо поглиблений аналіз нашого прикладу з факторіалом та додамо ілюстрації.



Коли ви викликаєте factorial(5), створюється перший шар у стеку викликів для цього виклику. Оскільки ця функція викликає себе знову, створюється ще один шар стеку для factorial(4), потім ще один для factorial(3) і так далі, доки не буде досягнуто базового випадку factorial(1). У цей момент рекурсія досягла своєї найбільшої глибини, і стек викликів містить п'ять шарів.






Завершення виконання factorial(1) починає процес "розвантаження" стеку.



Кожен шар, починаючи з останнього, обробляється, і результат кожного виклику повертається до попереднього виклику, доки весь стек не буде оброблений, і ми не отримаємо кінцевий результат для factorial(5).






Рекурсивні функції зручні в ситуаціях, коли ми не знаємо заздалегідь, скільки разів потрібно буде викликати функцію, наприклад, при розборі директорій на диску. Застосунок не знає заздалегідь, наскільки глибока структура директорій і який у них рівень вкладеності. І щоб перебрати усі файли в усіх вкладених директоріях, функція повинна викликати сама себе, коли зустрічає чергову директорію. Така функція, яка викликає сама себе за деяких умов, називається рекурсивною.

1. Для чого використовуються функції у Python?

--Для зміни значень змінних
!-Для групування та повторного виклику коду
--Тільки для математичних обчислень
--Для створення нових типів даних

Вірно! Функції у Python використовуються для групування коду, що виконує певну задачу, для його подальшого повторного виклику.

2. Як створюється та викликається функція у Python?

--Використовуючи ключове слово function
--Через пряме присвоєння коду змінній
!-Використовуючи ключове слово def та дужки ()
--Через автоматичний імпорт з іншого файлу

Вірно! Функція у Python створюється за допомогою ключового слова def, за яким слідує ім'я функції та пара дужок ().

3. Що таке параметри у функції Python?

--Значення, що передаються функції під час її виклику
!-Перемінні, які використовуються всередині функції
--Цикли, які використовуються у функції
--Зовнішні бібліотеки, що імпортуються в функцію

Параметри функції в Python - це не значення, передані під час виклику, а оголошені змінні, які приймають ці значення.

4. Що таке типізація ("type hints") у Python?

--Коментарі для опису коду
!-Підказки для типізації параметрів функції
--Вказівки для імпорту бібліотек
--Помилки виконання

Вірно! "Type hints" в Python використовуються для вказівки очікуваних типів параметрів у функціях.

5. Що таке LEGB у Python?

--Логічна структура програми
--Послідовність виконання коду
!-Правило областей видимості змінних
--Вбудовані функції Python

Вірно! LEGB в Python - це правило, що визначає області видимості змінних: Local, Enclosing, Global, Built-in.

6. Що таке ключові аргументи у Python?

--Аргументи, що вказуються за їх порядковим номером
--Аргументи, які використовуються для циклів
!-Аргументи, які обов'язково потрібно вказувати
--Аргументи, що вказуються за їх ім'ям

Вірно! Ключові аргументи у Python - це аргументи, що передаються у функцію за їх ім'ям, дозволяючи вказувати їх у будь-якому порядку.

7. Як працює змінна кількість параметрів у Python?

--Дозволяє викликати функцію без параметрів
--Вимагає вказувати всі параметри при кожному виклику
!-Дозволяє функції приймати будь-яку кількість аргументів
--Обмежує кількість параметрів, які може приймати функція

Вірно! Змінна кількість параметрів у Python дозволяє функції приймати нефіксовану кількість аргументів.

8. Що таке рекурсія у Python?

!-Виклик функції самою собою в рамках її виконання
--Використання випадкових значень у функції
--Повторення коду до досягнення певної умови
--Передача даних між різними функціями

Вірно! Рекурсія у Python - це коли функція викликає саму себе в рамках свого виконання, що дозволяє розбивати проблему на менші частини