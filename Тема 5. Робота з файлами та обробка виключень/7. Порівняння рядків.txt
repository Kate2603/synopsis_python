Порівняння рядків

Принцип порівняння рядків, з перетворенням їх у єдиний регістр, використовується для забезпечення 
нерозрізнення регістру при порівнянні. Це особливо корисно, коли порівняння повинно бути 
незалежним від того, чи введено рядок у верхньому, нижньому чи змішаному регістрі.

Основні кроки процесу порівняння наступні.

Перше, це перетворення рядків у єдиний регістр. Це може бути або перетворення всіх символів 
рядка у нижній регістр за допомогою методу .lower(), або у верхній регістр за допомогою .upper().

Далі сама операція порівняння рядків. Після перетворення обох рядків у однаковий регістр, 
вони порівнюються. Якщо рядки однакові після перетворення, вони вважаються еквівалентними 
у контексті нерозрізнення регістру.

✂️ Цей код можна запустити! 

string1 = "Hello World"
string2 = "hello world"
if string1.lower() == string2.lower():
    print("Рядки однакові")
else:
    print("Рядки різні")

Виведення:

Рядки однакові

Коли використовують саме таку техніку порівняння рядків? При пошуку або фільтрації даних, 
де важливо ігнорувати різницю у регістрі наприклад, пошук користувача за ім'ям в базі даних. 
У веб-застосунках, для забезпечення консистентного порівняння введених даних наприклад, при 
вході в систему або пошуку на сайті.

Але порівняння рядків у Python може давати неоднозначний результат внаслідок того, що в UTF-8 
кодуванні один і той самий символ можна представити декількома кодами, наприклад, символ 'ê' 
можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. З цієї 
причини порівняння одного і того самого символу може повернути False через відмінності у записі.

Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх 
необхідно нормалізувати за допомогою методу casefold, який повертає рядок, де всі символи 
у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису.

Цей метод схожий на lower(), але casefold() є більш радикальним: він призначений для видалення 
усіх відмінностей у регістрі, які можуть виникати в різних мовах, і тому є більш ефективним 
для випадків, де потрібно забезпечити нерозрізнення регістру в різноманітних мовах.

text = "Python Programming"
print(text.casefold())

Виведення буде 'python programming' таке саме як і для методу .lower().

Але головне застосування casefold() для мов, де одна літера може мати різні верхній та нижній 
регістри, наприклад, в німецькій мові.

У німецькій мові, літера "ß" (так званий "sharp S" або "eszett") використовується для 
позначення специфічного звука, що наближений до подвоєного "ss". Ця літера не має прямого 
еквіваленту у верхньому регістрі. Традиційно, коли слово, що містить "ß", потрібно написати 
великими літерами, "ß" перетворюється на "SS".

Ось тут casefold() виявляється корисним:

✂️ Цей код можна запустити! 

german_word = 'straße'  # В нижньому регістрі
search_word = 'STRASSE'  # В верхньому регістрі

# Порівняння за допомогою lower()
lower_comparison = german_word.lower() == search_word.lower()

# Порівняння за допомогою casefold()
casefold_comparison = german_word.casefold() == search_word.casefold()

print(f"Порівняння з lower(): {lower_comparison}")
print(f"Порівняння з casefold(): {casefold_comparison}")

У цьому прикладі, casefold() правильно вважатиме, що рядки "straße" та "STRASSE" еквівалентні, 
оскільки він враховує особливе перетворення "ß" в "ss". Це може бути важливо у сценаріях, де 
необхідно забезпечити точне порівняння тексту незалежно від регістру, наприклад, при пошуку 
у базі даних або при введенні даних користувачем.

Виведення:

Порівняння з lower(): False
Порівняння з casefold(): True

Цей випадок показує, що casefold() є більш ефективним для мов, які мають особливі правила 
перетворення символів у різних регістрах. У більшості життєвих сценаріїв, особливо при роботі 
з англійським текстом, lower() і casefold() будуть працювати подібно, але casefold() надає 
додаткову точність для специфічних мовних випадків.