Асоціація, композиція та агрегація в ООП



Просте наслідування в ООП дозволяє класу наслідувати поведінку та властивості іншого класу. Хоча це потужний інструмент для уникнення дублювання коду, він має певні обмеження. Наслідування створює тісну залежність між базовим класом та похідними класами. Зміни в базовому класі можуть несподівано вплинути на поведінку похідних класів. Наслідування може призвести до спадкування методів, які не мають сенсу для похідного класу, що може призвести до неочікуваної або помилкової поведінки.



Асоціація пропонує альтернативу наслідуванню, яка може уникнути деяких його недоліків. Асоціація в ООП - це концепція, яка описує відносини між класами через їх об'єкти. У цьому контексті, клас може включати в себе інший клас як одне зі своїх полів, що описується словом "має".



Асоціація поділяється на два основних типи: композиція та агрегація, кожен з яких має свої особливості та застосування.



Агрегація - це тип відношення між об'єктами, яке також представляє відносини "ціле" до "частини", але в цьому випадку "частини" можуть існувати незалежно від "цілого". Це означає, що якщо "ціле" буде знищено, "частини" можуть продовжувати існувати самостійно. Агрегація вказує на більш слабку залежність між об'єктами і часто використовується, коли об'єкти можуть входити до складу різних груп або колекцій. Наприклад, бібліотека (ціле) може містити книги (частини) через агрегацію; якщо бібліотека закриється, книги все одно залишаться і можуть бути переміщені до іншої бібліотеки.



Розглянемо приклад, який ілюструє, чому наслідування не є найкращим рішенням, і як асоціація між цими класами через агрегацію є більш відповідним підходом.



Спочатку розглянемо ситуацію, де ми могли б неправильно вирішити використати наслідування. Маємо клас Owner для господаря кішки та клас Cat для самої кішки.



class Owner:
    def __init__(self, name, phone):
        self.name = name
        self.phone = phone

    def info(self):
        return f"{self.name}: {self.phone}"

class Cat(Owner):
    def __init__(self, nickname, age, name, phone):
        super().__init__(name, phone)
        self.nickname = nickname
        self.age = age

    def cat_info(self):
        return f"Cat Name: {self.nickname}, Age: {self.age}"

		def sound(self):
		        return "Meow"

cat = Cat('Simon', 4, 'Boris', '+380503002010')
print(cat.info())
print(cat.cat_info())



Виведення:

Boris: +380503002010
Cat Name: Simon, Age: 4



Може здатися, що це добра ідея зробити кішку "частиною" господаря, використовуючи наслідування. Це б виглядало так, ніби ми кажемо: "Кішка є господарем". Але це не має сенсу, правда? Кішка і господар - це дві різні речі.

Кішка не може бути господарем. Вона просто має господаря.



Натомість, ми повинні показати, що кішка "має" господаря. Це не робить кішку господарем. Просто означає, що між кішкою та людиною є зв'язок. Людина - це господар кішки, а кішка - це вихованець цієї людини.



class Owner:
    def __init__(self, name: str, phone: str):
        self.name = name
        self.phone = phone

    def info(self):
        return f"{self.name}: {self.phone}"

class Cat(Owner):
    def __init__(self, nickname: str, age: int, owner: Owner):
        self.nickname = nickname
        self.age = age
        self.owner = owner

    def get_info(self):
        return f"Cat Name: {self.nickname}, Age: {self.age}"

    def sound(self):
        return "Meow"

owner = Owner("Boris", "+380503002010")
cat = Cat("Simon", 4, owner)
print(cat.owner.info())
print(cat.get_info())



Виведення:

Boris: +380503002010
Cat Name: Simon, Age: 4



У цьому прикладі, Cat та Owner асоційовані через агрегацію, де Cat має посилання на Owner, але об'єкти Owner можуть існувати незалежно від Cat. Тут ми кажемо: "Кішка має господаря", що є більш логічним і правильним з точки зору нашої програми. Це відображає реальні відносини між кішками та їх господарями більш точно та дозволяє кішкам мати або не мати господаря без порушення логіки.



☝ Агрегація дозволяє "частині" існувати незалежно від "цілого". У нашому прикладі, це означає, що господар може існувати окремо від улюбленця. Екземпляр господаря створюється незалежно і лише потім асоціюється з твариною, передаючись в конструктор вихованця як параметр.


Композиція - це тип відношення між об'єктами, де один об'єкт є частиною іншого. У відношенні композиції "частина" не може існувати без "цілого". Це означає, що якщо "ціле" буде знищено або видалено, то "частина" також буде знищена або видалена.



Композиція ефективно використовується в ситуаціях, де об'єкти мають сильну залежність один від одного, і "частина" не може існувати без "цілого". Тобто, якщо один об'єкт володіє іншим об'єктом і відповідальний за його життєвий цикл, то між ними існує відношення композиції.



Уявімо, що ми розробляємо програмне забезпечення для управління проектами. У цій системі кожен "Проект" (клас Project), може містити кілька "Задач" (клас Task), і ці задачі не мають сенсу поза контекстом свого проекту. Якщо проект видаляється, то всі його задачі також повинні бути видалені.



Розглянемо реалізацію



class Task:
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description

    def display_info(self):
        print(f"Задача: {self.name}, Опис: {self.description}")

class Project:
    def __init__(self, name: str):
        self.name = name
        self.tasks: list(Task) = []

    def add_task(self, name: str, description: str):
        self.tasks.append(Task(name, description))

    def remove_task(self, name: str):
        self.tasks = [task for task in self.tasks if task.name != name]

    def display_project_info(self):
        print(f"Проект: {self.name}")
        for task in self.tasks:
            task.display_info()

# Створення проекту
my_project = Project("Веб-розробка")

# Додавання задач
my_project.add_task("Дизайн інтерфейсу", "Створити макет головної сторінки.")
my_project.add_task("Розробка API", "Реалізувати ендпоінти для користувачів.")

# Відображення інформації про проект
my_project.display_project_info()

# Видалення задачі
my_project.remove_task("Розробка API")

# Перевірка видалення задачі
my_project.display_project_info()



Виведення:

Проект: Веб-розробка
Задача: Дизайн інтерфейсу, Опис: Створити макет головної сторінки. 
Задача: Розробка API, Опис: Реалізувати ендпоінти для користувачів.
Проект: Веб-розробка
Задача: Дизайн інтерфейсу, Опис: Створити макет головної сторінки.



У цьому прикладі, клас Project включає в себе об'єкти класу Task як "частини" проекту. Задачі створюються та керуються виключно через проект, що є яскравим прикладом композиції. Але чому тут підходить композиція? Життєвий цикл об'єктів Task тісно пов'язаний з життєвим циклом об'єкта Project. Задачі не можуть існувати без проекту. Клас Project "володіє" своїми Task. Це означає, що видалення проекту автоматично призведе до видалення всіх його задач.



Композиція дозволяє інкапсулювати поведінку та дані, пов'язані з управлінням задачами, всередині класу Project, що робить систему більш організованою та зрозумілою.



☝ Композиція є ідеальним вибором для моделювання відносин, де існує сильна залежність між об'єктами, і "частини" не можуть існувати самостійно без "цілого". Вона забезпечує чітку структуру володіння та керування об'єктами, підтримуючи цілісність та консистенцію системи.


Основна відмінність між композицією та агрегацією полягає в ступені залежності "частин" від "цілого". У композиції "частини" настільки залежні від "цілого", що не можуть існувати без нього, в той час як в агрегації "частини" мають більшу незалежність і можуть існувати окремо від "цілого". Вибір між цими двома типами відносин залежить від конкретної ситуації та того, наскільки сильною або слабкою має бути зв'язок між об'єктами у вашій моделі класів.