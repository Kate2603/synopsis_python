Різниця між полем і атрибутом класу

У ООП поле і атрибут класу - це два терміни, які часто використовуються як синоніми. Однак між ними є тонка різниця.



Змінна класу або атрибут – це змінна, яка зберігається в класі та доступ до них мають усі екземпляри цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, коли змінює змінну класу, змінює її для решти екземплярів цього ж класу.



Змінна об'єкту або поле - це змінна, яка зберігається в об'єкті. Вона належать кожному окремому екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, тобто вона жодним чином не пов'язана з іншими такими ж полями в інших екземплярах.






Розглянемо наступний приклад:



class Person:
    count = 0

    def __init__(self, name: str):
        self.name = name
        Person.count += 1

    def how_many_persons(self):
        print(f"Кількість людей зараз {Person.count}")

first = Person('Boris')
first.how_many_persons()
second = Person('Alex')
first.how_many_persons()



Виведення:

Кількість людей зараз 1
Кількість людей зараз 2



Тут count належить класу Person і є атрибутом класу. Його значення завжди одне й те саме для любого об'єкту класу. Змінна name належить об'єкту та є змінною об'єкту, і надає значення за допомогою self. Його значення для кожного об'єкту своє. Як бачимо з прикладу, звернення до атрибуту класу Person можна виконати як Person.count. До поля об'єкта name, у всіх методах цього об'єкта, ми звертаємось тільки за допомогою позначення self.name.



Але якщо ми введемо змінну об'єкта з тим самим ім'ям, що й змінну класу, це зробить недоступною змінну класу для читання через об'єкт.



class Person:
    count = 0

    def __init__(self):
        pass

person = Person()
print(person.count)  # 0



В цьому прикладі ми маємо доступ до змінної класу count, а у наступному прикладі вже ні.



class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10



Як бачимо person.count повертає 10. Це значення поля. Але ми завжди маємо доступ до змінної класу через ім'я класу: Person.count



class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10
print(Person.count)  # 0



Тут person.count повертає 10 - значення поля об'єкту person, а Person.count повертає атрибут класу зі значенням 0.



Але головна різниця полягає не в способі оголошення, а в тому, як і де ці змінні змінюються та використовуються у класі. Повернемось до прикладу:



class Person:
    count = 0

person = Person()
person.count = 10 
print(person.count)  # 10
print(Person.count)  # 0



Це оголошення створює змінну класу count для класу Person. Ця змінна є загальною для всіх екземплярів класу Person.



class Person:
    count = 0



Далі ми створюємо об'єкт person класу Person. В наступному рядку person.count = 10. У цей момент ми не змінюємо змінну класу count, яка була оголошена у класі Person. Натомість, ми створюємо нову змінну екземпляра count специфічну для об'єкту person. Так, конструктора немає, але Python автоматично створює поле для об'єкту, коли ми намагаємось йому, щось присвоїти. Тепер person має свою власну змінну count, яка перекриває змінну класу із тим же ім'ям. Рядок print(person.count) виводить 10, оскільки ми звертаємось до поля count об'єкту person. А ось рядок print(Person.count) виводить 0, оскільки ми звертаємось безпосередньо до атрибуту count класу Person. Ця змінна класу не змінилася, оскільки ми змінили лише змінну екземпляра для конкретного екземпляра person.



Отже, основна різниця полягає в області видимості та власності цих змінних. Змінні екземпляра прив'язані до конкретних об'єктів, тоді як змінні класу належать самому класу та спільні для всіх його екземплярів.





Практичний приклад

Для кращого розуміння та візуалізації основних принципів, про які ми щойно розповідали, давайте розглянемо конкретний приклад. Цей приклад ілюструє використання класів та роботу з його атрибутами і методами.



Ми створимо клас Pokemon, що ілюструє основні принципи об'єктно-орієнтованого програмування (ООП), а потім створимо об'єкт класу Pokemon - pikachu. Клас Pokemon буде містити атрибути: name, type, і health.



Для класу ми визначимо наступні методи:



attack (напад) - дозволяє покемону атакувати іншого покемона.
dodge (уклон) - дає можливість уникнути атаки.
evolve (еволюціонувати) - дозволяє покемону еволюціонувати в іншу форму.


class Pokemon:
    def __init__(self, name, type, health):
        self.name = name
        self.type = type
        self.health = health

    def attack(self, other_pokemon):
        print(f"{self.name} attacks {other_pokemon.name}!")

    def dodge(self):
        print(f"{self.name} dodged the attack!")

    def evolve(self, new_form):
        print(f"{self.name} is evolving into {new_form}!")
        self.name = new_form

# Створення об'єкта Pikachu
pikachu = Pokemon("Pikachu", "Electric", 100)

# Використання методів
pikachu.attack(Pokemon("Charmander", "Fire", 100))
pikachu.dodge()
pikachu.evolve("Raichu")



У цьому прикладі ми створили клас Pokemon та об'єкт pikachu, який може атакувати, ухилятися та еволюціонувати. Конструктор класу Pokemon буде викликатися, коли створюється новий екземпляр класу. Він ініціалізує екземпляр класу (об'єкт) з іменем name, типом покемона type, та здоров'ям health.



def __init__(self, name, type, health):
        self.name = name  # Ініціалізація атрибута імені
        self.type = type  # Ініціалізація атрибута типу
        self.health = health  # Ініціалізація атрибута здоров'я



Далі поглянемо, що роблять методи класу Pokemon. Метод attack дозволяє об'єкту Pokemon "атакувати" інший об'єкт Pokemon. Він виводить повідомлення про атаку, вказуючи імена обох покемонів. Метод dodge симулює ухилення покемона від атаки. Виводить повідомлення, що покемон ухилився від атаки. Метод evolve дозволяє покемону еволюціонувати, змінюючи його ім'я на нову форму.

Виводить повідомлення про еволюцію та оновлює атрибут імені.



Створюємо екземпляр pikachu класу Pokemon, ініціалізуючи його з іменем "Pikachu", типом "Electric" та здоров'ям 100.



pikachu = Pokemon("Pikachu", "Electric", 100)



Далі pikachu атакує новий екземпляр Pokemon з іменем "Charmander". Це демонструє, як метод attack може приймати інший об'єкт Pokemon як параметр.



pikachu.dodge()



Симулюємо ухилення pikachu від атаки, використовуючи метод dodge.



pikachu.evolve("Raichu")



Виконуємо еволюцію pikachu в "Raichu", використовуючи метод evolve. Це змінить значення атрибуту name об'єкта pikachu на "Raichu".



Виведення виконання коду:



Pikachu attacks Charmander!
Pikachu dodged the attack!
Pikachu is evolving into Raichu!



Наш код демонструє базові принципи ООП в Python, включаючи створення класу, визначення атрибутів і методів, створення екземпляра класу та взаємодію з його атрибутами і методами.



Настав час розібратися за концепціями ООП.