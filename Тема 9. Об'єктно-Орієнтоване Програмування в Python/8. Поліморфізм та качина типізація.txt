Поліморфізм та качина типізація

Останню концепцію ООП яку ми розглянемо це поліморфізм. Поліморфізм - це один із ключових концептів ООП, який дозволяє об'єктам мати різні форми або поведінку, базуючись на їх типах.



Поліморфізм походить від грецьких слів "polys" (багато) та "morph" (форма). У контексті ООП, це відноситься до здатності різних класів використовувати методи з однаковою назвою, але з різною реалізацією. Це дозволяє використовувати один інтерфейс для різних типів даних.



Коли ми розглядали наслідування у прикладі з тваринами, ми вже бачили динамічний поліморфізм:



class Animal:
    def __init__(self, nickname: str, age: int):
        self.nickname = nickname
        self.age = age

    def make_sound(self):
        pass

class Cat(Animal):
    def make_sound(self):
        return "Meow"

class Dog(Animal):
    def make_sound(self):
        return "Woof"

def animal_sounds(animals):
    for animal in animals:
        print(animal.make_sound())

animals = [Cat("Simon", 4), Dog("Rex", 5)]
animal_sounds(animals)



Тут make_sound - це метод, що використовується у кожному класі, але його реалізація різна для Cat та Dog. Це дозволяє нам викликати make_sound на екземплярі Animal, не знаючи точно, чи це Cat, Dog, чи інший підклас Animal. Ми створили функцію animal_sounds яка приймає список тварин і в принципі не важливо якого вони типу, головне, щоб вони реалізували метод make_sound:



Meow
Woof



Отже поліморфізм дозволяє обробляти об'єкти різних класів, які є похідними від одного базового класу, через спільний інтерфейс (тобто через однакові методи).



Таким чином, поліморфізм дозволяє функції animal_sounds взаємодіяти з об'єктами Cat та Dog як з об'єктами Animal, використовуючи їхні спільні інтерфейси, не зважаючи на різницю в їх внутрішній реалізації. Це робить код більш гнучким і він легше адаптується до змін, оскільки ми можемо додавати нові класи, які наслідують від Animal, без необхідності змінювати функцію animal_sounds.



З поліморфізмом тісно пов'язано поняття качина типізація.



Качина типізація (Duck Typing) - це концепція в програмуванні, яка відіграє важливу роль в динамічно типізованих мовах, таких як Python. Назва походить від англійського вислову "Якщо це ходить як качка і крякає як качка, то це, ймовірно, качка".



У контексті програмування, качина типізація означає, що замість перевірки типу об'єкта перед його використанням, важливіше зосередитися на тому, чи має об'єкт потрібні методи чи властивості, які вимагаються для виконання певної функції або операції.



Механізм Python дозволяє використовувати будь-які об'єкти один замість іншого, аби в обох були потрібні методи та поля. Інтерпретатор не перевіряє, що у функцію або метод був переданий об'єкт потрібного або дочірнього класу, достатньо щоб в об'єкта були потрібні методи і все буде працювати.



class Duck:
    def quack(self):
        print("Quack, quack!")

class Person:
    def quack(self):
        print("I'm Quacking Like a Duck!")

def make_it_quack(duck):
    duck.quack()

duck = Duck()
person = Person()

make_it_quack(duck)
make_it_quack(person)



Виведення:

Quack, quack!
I'm Quacking Like a Duck!



У цьому прикладі, функція make_it_quack приймає параметр duck, але фактично не перевіряє, чи це дійсно об'єкт класу Duck. Замість цього, вона просто викликає метод quack на переданому об'єкті. Якщо об'єкт має метод quack, він може бути використаний функцією make_it_quack незалежно від його фактичного типу. Це і є сутність качиної типізації. Головне, щоб атрибут називався так само і приймав ті самі аргументи (якщо це метод).



В такому підході є переваги так і недоліки. До переваг можна віднести, що код стає більш гнучким, оскільки він може працювати з будь-яким об'єктом, що відповідає певному інтерфейсу або поведінці. Перевагою є зниження залежності від конкретних типів, що сприяє більш модульній архітектурі.



Але виникає можливість помилок у виконанні часу, коли передається об'єкт, який не має необхідного методу або властивості, що є досить великим недоліком. Це може ускладнити читання та розуміння коду, оскільки не завжди очевидно, яких інтерфейсів очікує функція або метод.



Python є динамічно типізованою мовою, але з версії 3.5, в мову було додано підтримку для анотацій типів. Ці анотації типів дозволяють розробникам вказувати очікувані типи для змінних, аргументів функцій та значень, які функції повертають. Чим ми і користуємось в конспекті. Але використання таких анотацій типів відбувається на власний розсуд розробника і не є обов'язковим.



Качина типізація зосереджена на поведінці (методах та властивостях) об'єкта, а не на його конкретному типі. Це відповідає ідеології "якщо воно веде себе як качка, то це, ймовірно, качка".



Статична типізація допомагає підвищити читабельність коду, полегшити рефакторинг і зменшити кількість помилок, які можуть бути виявлені ще до виконання програми. Вона використовується для вказівки та перевірки типів даних.



У Python можна використовувати статичну типізацію для анотації типів і одночасно покладатися на качину типізацію для поліморфізму та гнучкої поведінки об'єктів.



Розглянемо наступний приклад:



class Dog:
    def speak(self) -> str:
        return "Woof"

class Cat:
    def speak(self) -> str:
        return "Meow"

class Robot:
    def speak(self) -> str:
        return "Beep boop"

def make_it_speak(speaker) -> None:
    print(speaker.speak())

dog = Dog()
cat = Cat()
robot = Robot()

make_it_speak(dog)  # Виведе: Woof
make_it_speak(cat)  # Виведе: Meow
make_it_speak(robot)  # Виведе: Beep boop



Виведення:

Woof
Meow
Beep boop



У цьому прикладі, качина типізація дозволяє нам передавати будь-який об'єкт, який має метод speak, у функцію make_it_speak, не зважаючи на його конкретний клас. Але, що стосується типу параметру speaker для функції make_it_speak?



Щоб занотувати тип параметра функції speaker ми можемо використати typing.Protocol, який визначає набір методів, які цей параметр має виконувати, не прив'язуючись до конкретного класу.



Створимо інтерфейс, використовуючи typing.Protocol, для об'єктів, які можуть "говорити". Ми хочемо, щоб будь-який об'єкт, який має метод speak, вважався сумісним з цим інтерфейсом.



from typing import Protocol

class Speaker(Protocol):
    def speak(self) -> str:
        pass

class Dog:
    def speak(self) -> str:
        return "Woof"

class Cat:
    def speak(self) -> str:
        return "Meow"

class Robot:
    def speak(self) -> str:
        return "Beep boop"

def make_it_speak(speaker: Speaker) -> None:
    print(speaker.speak())

dog = Dog()
cat = Cat()
robot = Robot()

make_it_speak(dog)  # Виведе: Woof
make_it_speak(cat)  # Виведе: Meow
make_it_speak(robot)  # Виведе: Beep boop



Результат буде той самий але статична типізація за допомогою typing.Protocol використовується для вказівки, що параметр speaker повинен відповідати інтерфейсу, який має метод speak.



Таким чином, статична типізація допомагає забезпечити правильність типів на етапі розробки, а качина типізація забезпечує гнучкість у виконанні, дозволяючи об'єктам різних класів використовувати спільний інтерфейс.

1. Що таке об'єктно-орієнтоване програмування (ООП)?

-- Програмування, засноване на функціях
-- Програмування, що використовує цикли
!- Програмування, засноване на взаємодії об'єктів
-- Програмування, що використовує умовні оператори

Вірно! ООП - це парадигма програмування, що використовує об'єкти та класи для моделювання реального світу.

2. Що таке клас у контексті ООП?

-- Змінна, що зберігає дані
-- Функція для обробки даних
!- Шаблон для створення об'єктів
-- Команда для виконання програми

Вірно! Клас - це шаблон, з якого створюються об'єкти.

3. Як створити простий клас у Python?

!- Використовуючи ключове слово class
-- За допомогою функції def
-- За допомогою ключового слова import
-- Використовуючи оператор =

Вірно! Ключове слово class використовується для визначення нового класу.

4. Що таке метод __init__ у класах Python?

-- Функція, що викликається для видалення об'єкта
!- Метод, що автоматично викликається при створенні об'єкта
-- Функція для додавання нових атрибутів
-- Метод для виведення даних об'єкта

Метод __init__ спеціально призначений для ініціалізації об'єктів, а не для їх видалення чи інших цілей.

5. Як правильно використовувати аргумент self у методах класу?

-- Для вказівки на глобальні змінні
-- Для передачі даних між функціями
!- Для доступу до атрибутів та методів об'єкта
-- Як ключове слово для створення нових методів

Вірно! self використовується для доступу до атрибутів і методів конкретного екземпляра класу.

6. Яка різниця між класом та об'єктом?

-- Клас це програма, а об'єкт це дані
!- Клас це шаблон, об'єкт це екземпляр класу
-- Клас і об'єкт це синоніми
-- Об'єкт створює класи, а клас визначає тип об'єкта

Вірно! Клас слугує шаблоном для створення об'єктів, які є конкретними екземплярами цього класу.

7. Що таке атрибут класу та як його визначити?

!- Змінна, визначена за межами методів класу
-- Змінна, що передається методам класу
-- Коментар в коді класу
-- Функція всередині класу

Атрибути класу відрізняються від локальних змінних методів і не визначаються через декоратори чи в параметрах функцій.

8. Як методи класу можуть взаємодіяти з полями класу?

-- Через прямий доступ до змінних
-- Використовуючи ключове слово static
-- Через глобальні змінні
!- Використовуючи ключове слово self

Вірно! Методи можуть звертатися до атрибутів екземпляра через self.

9. Яка різниця між атрибутами класу та полями класу?

-- Атрибути класу можна змінювати, а поля неможливо змінювати
!- Атрибути класу спільні для всіх екземплярів, а поля унікальні для кожного екземпляра
-- Атрибути класу зберігаються у файлі
-- Поля доступні тільки в методах класу

Атрибути класу і поля відрізняються своєю сферою видимості та доступності.

10. Як створити клас з декількома методами та викликати ці методи для екземпляра класу?

-- Використовуючи ключове слово import
-- Задаючи методи як глобальні функції
!- Оголошуючи методи всередині класу та викликаючи їх через екземпляр
-- Створюючи кожен метод у своєму файлі

Вірно! Методи оголошуються всередині класу та викликаються через екземпляр класу з використанням нотації крапки.