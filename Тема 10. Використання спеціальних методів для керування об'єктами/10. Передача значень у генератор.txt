Передача значень у генератор

Оператор yield має більш рідкісне застосування, він може повертати значення 
так само, як і виклик функції. Це дозволяє передавати значення в генератор за 
допомогою виклику методу send.

Метод send() використовується для взаємодії з генератором шляхом надсилання 
значення у генератор, яке потім може бути використане як результат виразу yield. 
Це дозволяє генератору не лише виробляти дані, але й обробляти зовнішні дані на кожній ітерації.

def my_generator():
    received = yield "Ready"
    yield f"Received: {received}"

gen = my_generator()
print(next(gen))  
print(gen.send("Hello"))  

Метод send() використовується для передачі значення безпосередньо в генератор. 
Значення, передане через send(), стає результатом виразу yield, де генератор був 
призупинений. Це дозволяє генераторам не тільки виробляти значення, але й приймати 
дані в будь-який момент їх виконання.

Виведення:

Ready
Received: Hello

Запускаємо генератор next(gen) і отримуємо перше повідомлення "Ready" . 
Відправляємо дані в генератор gen.send("Hello") і отримуємо наступне значення "Received: Hello".

Коли генератору більше не потрібно виробляти значення, його можна закрити за 
допомогою методу close(). При цьому в генераторі викликається виключення 
GeneratorExit, яке можна перехопити для виконання якихось дій перед закриттям генератора.

def my_generator():
    try:
        yield "Working"
    except GeneratorExit:
        print("Generator is being closed")

gen = my_generator()
print(next(gen))  # Отримуємо "Working"
gen.close()  # Викликаємо закриття генератора

Виведення:

Working
Generator is being closed

Ці механізми дозволяють реалізувати досить складну логіку взаємодії між кодом 
та генераторами, забезпечуючи гнучкість та контроль над процесом виконання генераторів.

Для прикладу створимо генератор, який може приймати рядки тексту, фільтрувати їх за 
певним критерієм (наприклад, повертати рядок, якщо він містить певне слово), і повертати 
тільки ті рядки, які відповідають цьому критерію.

Спочатку розглянемо простий приклад. Створимо генератор square_numbers() , який буде 
приймати числа через метод send() та виконувати обчислення, візьмемо просту операцію 
піднесення до квадрату, та повертати результат через yield.

def square_numbers():
    try:
        while True:  # Безкінечний цикл для прийому чисел
            number = yield  # Отримання числа через send()
            square = number ** 2  # Піднесення до квадрата
            yield square  # Повернення результату
    except GeneratorExit:
        print("Generator closed")

# Створення і старт генератора
gen = square_numbers()

# Ініціалізація генератора
next(gen)  # Або gen.send(None), щоб стартувати

# Відправлення числа в генератор і отримання результату
result = gen.send(10)  # Повинно повернути 100
print(f"Square of 10: {result}")

# Перехід до наступного очікування
next(gen)

# Відправлення іншого числа
result = gen.send(5)  # Повинно повернути 25
print(f"Square of 5: {result}")

# Закриття генератора
gen.close()

Виведення:

Square of 10: 100
Square of 5: 25
Generator closed

Ми створили генератор square_numbers, що приймає числа, підносить їх до квадрату, 
та повертає результат. В середині генератора ми використовуємо yield двічі. Спочатку 
для отримання числа через send() - інструкція number = yield. Потім для повернення 
обчисленого квадрату числа - інструкція yield square.

В коді після кожного виклику send(), що передає число, нам потрібно викликати 
next(gen) або знову send(), щоб продовжити виконання генератора до наступного yield.
Це як раз і дозволяє генератору приймати нове значення.

Тепер розглянемо більш складний приклад. Створимо генератор filter_lines(), 
який чекатиме на вхідні рядки через метод send(). Всередині генератора буде перевірка: 
якщо рядок містить певне слово, він буде повернутий через yield.

def filter_lines(keyword):
    print(f"Looking for {keyword}")
    try:
        while True:  # Нескінченний цикл, де генератор чекає на вхідні дані
            line = yield  # Отримання рядка через send()
            if keyword in line:  # Перевірка на наявність ключового слова
                yield f"Line accepted: {line}"
            else:
                yield None
    except GeneratorExit:
        print("Generator closed")

if __name__ == "__main__":
    # Створення і старт генератора
    gen = filter_lines("hello")
    next(gen)  # Потрібно для старту генератора
    messages = ["this is a test", "hello world", "another hello world line", "hello again", "goodbye"]
    hello_messages = []
    # Відправлення даних у генератор
    for message in messages:
        result = gen.send(message)  # Відправляємо повідомлення в генератор
        if result:  # Додаємо результат тільки якщо він не None
            hello_messages.append(result)
        next(gen)  # Продовжуємо до наступного yield: інструкція line = yield

    # Закриття генератора
    gen.close()
    print(hello_messages)

Виведення:

Looking for hello
Generator closed
['Line accepted: hello world', 'Line accepted: another hello world line', 'Line accepted: hello again']

Спочатку ми створюємо і ініціалізуємо генератор filter_lines, вказуючи ключове слово для фільтрації.

gen = filter_lines("hello")

Потім ми активуємо генератор за допомогою next(gen). Це необхідно, щоб "дійти" 
до першого yield і підготувати генератор до прийому даних через send().

next(gen)  # Потрібно для старту генератора

Після активації ми відправляємо рядки в генератор через send(). Кожен раз, коли 
рядок містить ключове слово, генератор повертає рядок з відповідним повідомленням. 
Ми перевіряємо, чи повернене значення не є None, і якщо воно відповідає нашому 
критерію, додаємо його до списку hello_messages:

for message in messages:
    result = gen.send(message)  # Відправляємо повідомлення в генератор
    if result:  # Додаємо результат тільки якщо він не None
        hello_messages.append(result)
    next(gen)  # Продовжуємо до наступного yield

Тут, після кожного виклику send(), ми робимо додатковий виклик next(gen) для 
просування генератора через наступний цикл, дозволяючи йому приймати наступне 
значення. Це важливо, оскільки після yield, які повертають значення, наш генератор "зупиняється".

if keyword in line:  # Перевірка на наявність ключового слова
    yield f"Line accepted: {line}"
else:
    yield None

І щоб продовжити роботу генератора нам потрібен або виклик next(), або send(). 
Це змусить генератор перейти до рядка коду:

 line = yield  # Отримання рядка через send()

На завершення, ми закриваємо генератор за допомогою close(), щоб коректно 
завершити його роботу і викликати виключення GeneratorExit всередині генератора. 
Це гарантує, що всі ресурси належним чином звільняються, а генератор припиняє свою роботу.

Загалом такий підхід робить генератори потужним інструментом для асинхронного програмування, 
обробки потоків даних та реалізації кооперативної багатозадачності в Python.