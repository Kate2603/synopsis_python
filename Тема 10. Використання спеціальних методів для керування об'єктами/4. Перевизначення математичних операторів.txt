Перевизначення математичних операторів

Перевизначення математичних операторів в Python дозволяє класам змінювати стандартну 
поведінку арифметичних операцій. Це відомо як перевантаження операторів. Використовуючи 
спеціальні методи, ви можете визначити або перевизначити поведінку операторів, 
таких як +, -, *, /, і багатьох інших для об'єктів ваших класів.

Ось деякі з найпоширеніших спеціальних методів для перевизначення математичних операторів:

__add__(self, other) для оператора +
__sub__(self, other) для оператора -
__mul__(self, other) для оператора *
__truediv__(self, other) для оператора /
__floordiv__(self, other) для оператора цілочисельного ділення //
__mod__(self, other) для оператора залишку від ділення %
__pow__(self, other) для оператора * піднесення до степеня

Перевизначення математичних операторів може стати зручним інструментом. Наприклад, 
створимо клас словників, які підтримують операції додавання та віднімання:

from collections import UserDict

class MyDict(UserDict):
    def __add__(self, other):
        temp_dict = self.data.copy()
        temp_dict.update(other)
        return MyDict(temp_dict)

    def __sub__(self, other):
        temp_dict = self.data.copy()
        for key in other:
            if key in temp_dict:
                temp_dict.pop(key)
        return MyDict(temp_dict)

if __name__ == '__main__':
    d1 = MyDict({1: 'a', 2: 'b'})
    d2 = MyDict({3: 'c', 4: 'd'})

    d3 = d1 + d2
    print(d3)

    d4 = d3 - d2
    print(d4)

Виведення:

{1: 'a', 2: 'b', 3: 'c', 4: 'd'}
{1: 'a', 2: 'b'}

Синтаксис простий і код досить виразний.

Метод __add__ визначає поведінку для оператора +. Він дозволяє об'єднувати два об'єкти 
класу MyDict, додаючи всі елементи з другого словника other до першого (self). 
Спочатку створюється копія внутрішнього словника self.data, щоб уникнути зміни оригінального 
словника. До тимчасового словника додаються всі елементи з другого словника. Якщо ключі
 вже існують, їх значення будуть оновлені на значення з other. Магічний метод повертає 
 новий екземпляр MyDict, ініціалізований з об'єднаного словника.

Метод __sub__ визначає поведінку для оператора -. Він дозволяє видаляти ключі з першого 
словника self, які присутні в другому other. Аналогічно методу __add__, спочатку 
створюється копія внутрішнього словника temp_dict. Далі цикл for перебирає всі ключі 
в другому словнику other. Умова if key in temp_dict перевіряє, чи присутній ключ у 
словнику temp_dict. Якщо так то видаляємо ключ і його значення з тимчасового словника, 
якщо такий ключ існує. Повертаємо новий екземпляр MyDict, ініціалізований після видалення ключів.

Розглянемо ще один приклад та створимо клас ComplexNumber для представлення комплексних 
чисел, з перевизначенням деяких арифметичних операторів:

class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        return ComplexNumber(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other):
        return ComplexNumber(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other):
        real_part = self.real * other.real - self.imag * other.imag
        imag_part = self.real * other.imag + self.imag * other.real
        return ComplexNumber(real_part, imag_part)

    def __str__(self):
        return f"{self.real} + {self.imag}i"

if __name__ == "__main__":
    num1 = ComplexNumber(1, 2)
    num2 = ComplexNumber(3, 4)
    print(f"Сума: {num1 + num2}")
    print(f"Різниця: {num1 - num2}")
    print(f"Добуток: {num1 * num2}")

Виведення:

Сума: 4 + 6i
Різниця: -2 + -2i
Добуток: -5 + 10i

Наш приклад показує, як можна перевизначити арифметичні оператори для реалізації додавання, 
віднімання та множення комплексних чисел. Використання спеціальних методів робить можливим 
використання звичних математичних операторів з об'єктами, створюючи читабельний і інтуїтивно 
зрозумілий інтерфейс.

Перевизначення математичних операторів надає значні можливості для створення виразних і 
потужних абстракцій, що здатні імітувати поведінку вбудованих типів Python або створювати 
нові способи взаємодії з об'єктами ваших класів. Для прикладу реалізуємо векторне множення, 
де результатом є скалярний добуток векторів.

from collections import UserList

class MulArray(UserList):
    def __init__(self, *args):
        self.data = list(args)

    def __mul__(self, other):
        return self.__scalar_mul(other)
    
    def __rmul__(self, other):
        return self.__scalar_mul(other) 
    
    def __scalar_mul(self, other):
        result = 0
        for i in range(min(len(self.data), len(other))):
            result += self.data[i] * other[i]
        return result

if __name__ == '__main__':
    vec1 = MulArray(1, 2, 3)
    vec2 = MulArray(3, 4, 5)

    print(vec1 * vec2)
    print(vec1 * [1, 2, 3])
    print([1, 1, 1] * vec2)

Виведення:

26
14
12

Магічний метод __mul__ визначає поведінку операції множення * між екземпляром MulArray і іншим об'єктом. 
Він виконує скалярний добуток між self.data і другим списком, обмежуючи множення мінімальною довжиною 
обох списків. Результатом є сума добутків відповідних елементів списків. Тут в нас з'явився новий 
магічний метод __rmul__ який визначає поведінку операції множення, коли екземпляр MulArray знаходиться 
справа від оператора множення. Це забезпечує комутативність операції множення, дозволяючи виконувати 
множення з обох боків. Він необхідний, щоб ми могли виконати операцію [1, 1, 1] * vec2, 
коли екземпляр MulArray знаходиться справа від оператора множення. Реалізація ідентична до __mul__, 
тому результат буде таким же.