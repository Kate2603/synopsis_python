Управління атрибутами та методами в класах

Гетери і Сетери

У мові програмування Python, поля - це змінні, які зберігають інформацію про стан об'єкта. 
Доступ до цих полів та їх модифікація зазвичай відбувається безпосередньо, але іноді 
необхідно контролювати цей процес, наприклад, для валідації даних або інкапсуляції. 
Для цього існують спеціальні методи які називають гетерами та сетерами. В Python 
застосовують декоратор @property, який дозволяє їх зручно створювати та використовувати.

Гетери (від англ. get - отримувати) - це методи, які дозволяють отримати значення 
поля. Вони використовуються, коли доступ до поля потребує якоїсь додаткової обробки 
або коли безпосередній доступ до поля не бажаний з міркувань інкапсуляції. Наприклад, 
якщо потрібно завжди повертати значення поля у вигляді рядка, 
навіть якщо воно зберігається як число.

Сетери (від англ. set - встановлювати) - це методи, які дозволяють встановити 
значення поля. Вони найчастіше використовуються для валідації даних, які намагаються 
присвоїти полю. Наприклад, якщо ми маємо поле, який повинно приймати значення лише 
додатні числа, можна в сетері додати перевірку, яка буде викидати виняток або повертати
 помилку, якщо намагатися присвоїти йому від'ємне число.

Вбудований декоратор @property в Python дозволяє легко створювати гетери. 
Використання цього декоратора робить метод класу доступним як поле, тобто його 
можна буде викликати без дужок. Це робить інтерфейс класу більш чистим та 
інтуїтивно зрозумілим. Для створення сетера для того ж поля, що і гетер, 
використовується декоратор @property.setter, який застосовується до методу 
з тим же ім'ям, що і властивість.

Розглянемо приклад класу, який використовує @property для створення гетера 
та сетера для поля age. Ми хочемо, щоб age завжди був додатнім числом. Спочатку 
ми створимо метод age з декоратором @property, який буде виступати як гетер і 
повертати значення атрибута __age (приватна версія age, що використовується 
внутрішньо класом для зберігання реального значення). Потім ми створимо метод 
age з декоратором @property.setter, який буде виступати як сетер і валідувати 
вхідне значення перед його присвоєнням __age. Якщо значення не відповідає нашим 
критеріям (наприклад, якщо воно від'ємне), ми можемо викинути виняток або виконати
 інші дії для обробки помилки.

Почнемо з оголошення класу Person, який має приватний атрибут __age. 
Згадайте, що ми використовуємо підкреслення на початку імені атрибута, 
щоб позначити, що цей атрибут є внутрішнім і не повинен бути доступний для 
прямого доступу ззовні класу. Це стандартна практика для інкапсуляції, яка 
допомагає зберегти внутрішню реалізацію класу прихованою від користувача.

class Person:
    def __init__(self, age):
        self.__age = age  # Пряме присвоєння значення атрибуту в конструкторі

    @property
    def age(self):
        return self.__age  # Геттер повертає значення приватного поля

    @age.setter
    def age(self, value):
        if value < 0:
            # Валідація вхідного значення
            raise ValueError("Вік не може бути від'ємним")  
        # Присвоєння валідного значення приватному полю
        self.__age = value  

if __name__ == "__main__":
    person = Person(10)
    print(person.age)
    person.age = -5

Якщо ми захочемо присвоїти полю age від'ємне значення то отримаємо відповідну помилку. Виведення:

10
Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex25.py", line 19, in <module>
    person.age = -5
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex25.py", line 12, in age
    raise ValueError("Вік не може бути від'ємним")  # Валідація вхідного значення

ValueError: Вік не може бути від'ємним

У цьому прикладі, коли ми створюємо новий екземпляр класу Person, 
конструктор __init__ приймає вік як аргумент і присвоює його приватному 
атрибуту __age. Гетер для age просто повертає значення цього приватного 
атрибуту, дозволяючи зовнішньому коду отримувати вік особи без прямого 
доступу до внутрішньої реалізації.

@property
def age(self):
    return self.__age  # Геттер повертає значення приватного поля

Сетер age виконує валідацію вхідного значення перед його присвоєнням 
приватному полю __age. Якщо вказане значення є від'ємним, сетер генерує 
виняток ValueError, запобігаючи тим самим некоректному присвоєнню віку. 
Це забезпечує, що об'єкт Person завжди має валідний вік.

@age.setter
def age(self, value):
    if value < 0:
        # Валідація вхідного значення
        raise ValueError("Вік не може бути від'ємним")  
    # Присвоєння валідного значення приватному полю
    self.__age = value  

Використання гетерів та сетерів з декоратором @property дозволяє нам забезпечити 
контрольований доступ до полів класу, виконуючи необхідні перевірки або обробку 
при спробі читання або зміни їх значень. Це підвищує безпеку та надійність коду, 
дозволяючи розробникам визначати як атрибути мають бути використані, та які дії 
повинні бути виконані при їх зміні.

Виглядає все досить просто але є одна проблема. Якщо ми виконаємо наступний код

person = Person(-10)
print(person.age)

То ми не отримаємо ніякого сповіщення про помилку, а буде виведення:

-10

Виправимо цей недолік. Необхідно в конструкторі класу спочатку значення __age 
встановити в None, а потім встановити в передане значення age через сетер. 
Це дозволить нам одразу застосувати логіку валідації, визначену в сетері, при ініціалізації об'єкта.

class Person:
    def __init__(self, age):
        # Спочатку встановлюємо __age як None
        self.__age = None
        # Використовуємо сеттер для встановлення віку, що дозволяє валідацію вхідного значення
        self.age = age

    @property
    def age(self):
        # Геттер повертає значення приватного поля
        return self.__age

    @age.setter
    def age(self, value):
        if value < 0:
            # Валідація вхідного значення
            raise ValueError("Вік не може бути від'ємним")
        # Присвоєння валідного значення приватному полю
        self.__age = value

if __name__ == "__main__":
    person = Person(-10)
    print(person.age)

Тепер виконання викидає помилку як і повинно бути.

Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex26.py", line 23, in <module>
    person = Person(-10)
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex26.py", line 6, in __init__
    self.age = age
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex26.py", line 17, in age
    raise ValueError("Вік не може бути від'ємним")
ValueError: Вік не може бути від'ємним

У цьому варіанті, коли ми створюємо екземпляр класу Person, спочатку приватному п
олю __age присвоюється значення None. Потім викликається сетер age, передаючи йому 
олю __age присвоюється значення None. Потім викликається сетер age, передаючи йому 
, передане у конструктор. Це дозволяє нам використовувати логіку валідації,
 визначену в сетері, вже на етапі ініціалізації об'єкта, забезпечуючи, що 
 некоректні дані не будуть призначені атрибуту __age.
 
Такий підхід підвищує надійність і безпеку коду, оскільки він гарантує, що всі значення, 
які присвоюються важливому атрибуту об'єкта age, проходять через однаковий процес 
валідації незалежно від того, чи вони встановлені при створенні об'єкта, чи змінюються пізніше.

Тепер, озброївшись цими знаннями, давайте перепишемо приклад інкапсуляції з минулого 
модуля, через сетери та гетери.

class Person:
    def __init__(self, name: str, age: int, is_active: bool, is_admin: bool):
        self.name = name
        self.age = age
        self._is_active = None
        self.__is_admin = None
        self._is_active = is_active
        self.__is_admin = is_admin

    @property
    def is_active(self):
        return self._is_active

    @is_active.setter
    def is_active(self, value: bool):
        # Тут можна додати будь-яку логіку перевірки або обробки
        self._is_active = value

    @property
    def is_admin(self):
        return self.__is_admin

    @is_admin.setter
    def is_admin(self, value: bool):
        # Тут можна додати будь-яку логіку перевірки або обробки
        self.__is_admin = value

    def greeting(self):
        return f"Hi {self.name}"

if __name__ == "__main__":
    p = Person("Boris", 34, True, False)
    print(p.is_admin)  # Використовуємо геттер
    p.is_admin = True  # Використовуємо сеттер
    print(p.is_admin)

Використовуючи декоратор @property, ми створюємо гетери та сетери для захищеного та 
приватного поля. Це дозволяє нам контролювати доступ до цих атрибутів, забезпечуючи 
можливість валідації даних та інкапсуляції внутрішньої реалізації.

Виведення:

False
True



