Створення власних менеджерів контексту

Створення власного менеджера контексту в Python - це спосіб керування ресурсами, 
такими як файли, з'єднання з базою даних та інше, забезпечуючи їх автоматичне 
відкриття та закриття. Менеджер контексту гарантує, що ресурси будуть коректно 
звільнені після завершення блоку коду, навіть якщо в процесі виконання виникне виключення.

Об'єкти контекстних менеджерів слугують для управління оператором with ... as ...: 
так само як ітератори управляють оператором циклу for-in.

Для створення власного менеджера контексту необхідно реалізувати клас з магічними 
методами __enter__ та __exit__. Метод __enter__ викликається на початку блоку with,
коли інтерпретатор заходить у контекст і те, що він поверне, буде записано в змінну після as. 
Метод __exit__ викликається після завершення виконання блоку with, незалежно від того, 
виникло виключення чи ні.

Розглянемо поки досить абстрактний контекстний менеджер, щоб зрозуміти принцип його роботи.

class MyContextManager:
    def __enter__(self):
        # Ініціалізація ресурсу
        print("Enter the block")
        return self  # Може повертати об'єкт

    def __exit__(self, exc_type, exc_value, traceback):
        # Звільнення ресурсу
        print("Exit the block")
        if exc_type:
            print(f"Error detected: {exc_value}")
        # Повернення False передає виключення далі, True - поглинає виключення.
        return False

# Використання власного менеджера контексту
with MyContextManager() as my_resource:
    print("Inside the block")
    raise Exception("Something went wrong")

Спочатку виведення:

Enter the block
Inside the block
Exit the block
Error detected: Something went wrong
Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic7\\ex16.py", line 19, in <module>
    raise Exception("Something went wrong")
Exception: Something went wrong

На початку блоку with автоматично викликається метод __enter__ нашого класу MyContextManager. 
Метод друкує рядок тексту "Enter the block" і повертає self, який прив'язується до змінної 
my_resource. Однак у даному контексті ми не використовуємо його.

Далі виконується код всередині блоку with. У нашому прикладі це виведення рядка 
"Inside the block" та генерація виключення за допомогою raise Exception("Something went wrong").

Після генерації виключення, або просто після завершення виконання коду, якщо виключення не було, 
автоматично викликається метод __exit__. Цей метод використовується для виконання необхідних дій 
по звільненню ресурсів або очищенню. Метод __exit__ отримує інформацію про виключення, 
яке сталося всередині блоку with, через свої параметри exc_type, exc_value і traceback. 
У нашому випадку, оскільки виключення відбулося, exc_type не буде None, і метод __exit__ друкує 
рядок "Exit the block" та "Error detected: Something went wrong".

Оскільки в методі __exit__ ми повертаємо False, то виключення, яке було згенеровано всередині 
блоку with, не придушується і, як кажуть програмісти, прокидається далі. Це означає, що після 
виходу з методу __exit__, виключення буде оброблене інтерпретатором звичайним чином, що і 
призводить до виведення його Traceback помилки в консолі. Отже як працює виконання контекстного 
менеджеру ми розібрали.

Тепер поглянемо уважно на синтаксис методу __exit__. Він приймає три аргументи, які містять 
інформацію про будь-яке виключення, що виникло всередині блоку with.

def __exit__(self, exc_type, exc_val, exc_tb):
    # Звільнення ресурсів
    # exc_type: тип виключення
    # exc_val: значення виключення
    # exc_tb: трасування стека виключення
    return False  # Якщо True, виключення буде придушено, інакше - прокинуто далі

Якщо блок with завершився без помилки, то значення змінних exc_type , exc_val , 
exc_tb дорівнюють None . Але якщо була помилка, як в нашому прикладі то параметр 
exc_type буде зберігати тип виключення <class 'Exception'>, exc_val значення виключення 
"Something went wrong" і exc_tb об'єкт трасування стека виключення 
<traceback object at 0x0000018A15310A80>. Метод __exit__ не повинен перехоплювати 
винятки, він потрібен лише для того, щоб правильно завершити контекст 
(закрити відкриті файли та з'єднання, повернути ресурси системі тощо).

Як бачимо механізм створення досить важкий. Тому Python дозволяє створювати менеджери 
контексту за допомогою генераторів і декоратора contextmanager з модуля contextlib. 
Це спрощує створення менеджерів контексту, особливо коли вони використовуються для 
одноразових або простих задач.

from contextlib import contextmanager

@contextmanager
def my_context_manager():
    # Ініціалізація ресурсу
    print("Enter the block")
    try:
        yield  # Місце виконання блоку `with`
    except Exception as e:
        # Обробка виключень
        print(f"Error detected: {e}")
        # Можна ре-підняти виключення або вирішити його тут
        raise
    finally:
        # Звільнення ресурсу
        print("Exit the block")

# Використання
with my_context_manager():
    print("Inside the block")
    raise Exception("Something went wrong")

Декоратор @contextmanager використовується для перетворення функції my_context_manager 
в менеджер контексту. Це дозволяє використовувати функцію у конструкції with ... as ..., 
спрощуючи створення менеджерів контексту без необхідності визначати клас з 
методами __enter__ та __exit__. Виведення цього коду повинно бути аналогічним.

Але, думаю, хотілось би більш реальний та практичний приклад, щоб до кінця зрозуміти 
механізм виконання менеджеру контексту. Створимо клас FileManager, який призначений 
для роботи з файлами та логування процесу відкриття та закриття файлу.

class FileManager:
    def __init__(self, filename, mode='w', encoding='utf-8'):
        self.file = None
        self.opened = False
        self.filename = filename
        self.mode = mode
        self.encoding = encoding

    def __enter__(self):
        self.file = open(self.filename, self.mode, encoding=self.encoding)
        self.opened = True
        print("Відкриваємо файл", self.filename)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Завершення блоку with")
        if self.opened:
            print("Закриваємо файл", self.filename)
            self.file.close()
        self.opened = False


if __name__ == '__main__':
    with FileManager('new_file.txt') as f:
        f.write('Hello world!\n')
        f.write('The end\n')

Виведення:

Відкриваємо файл new_file.txt
Завершення блоку with
Закриваємо файл new_file.txt

Конструктор класу FileManager ініціалізує екземпляр класу з певним ім'ям файлу filename, 
режимом відкриття файлу mode, та кодуванням encoding. За замовчуванням, режим встановлено 
на 'w' (запис), а кодування на 'utf-8' .

Метод __enter__ виконується на початку блоку with. Він відкриває файл з вказаними 
параметрами і зберігає відкритий файловий об'єкт у змінній self.file, а також встановлює 
прапорець self.opened в значення True. Ми виводимо сповіщення, що файл відкритий та 
повертаємо файловий об'єкт, що дозволяє використовувати його в контексті with. Фактично 
змінна f це self.file який повернув метод __enter__.

Метод __exit__ викликається при виході з блоку with, незалежно від того, виникла помилка 
чи ні при роботі з файлом. Ми перевіряємо прапорець self.opened і якщо він True то необхідно 
закрити файл, а далі встановлюємо прапорець в False.

Декоратор @contextmanager дозволяє нам створити контекстний менеджер за допомогою генератора, 
та спростити написання коду порівняно з класом FileManager, який 
використовує методи __enter__ та __exit__.

from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode='w', encoding='utf-8'):
    print("Відкриваємо файл", filename)
    file = open(filename, mode, encoding=encoding)
    try:
        yield file
    finally:
        print("Закриваємо файл", filename)
        file.close()
        print("Завершення блоку with")


if __name__ == '__main__':
    with file_manager('new_file.txt') as f:
        f.write('Hello world!\n')
        f.write('The end\n')

У цьому коді функція file_manager визначена з декоратором @contextmanager. Вона відкриває 
файл і виводить повідомлення про відкриття, потім використовує yield для передачі 
файлового об'єкта у контекстний блок. Після виходу з блоку with код у блоку finally 
гарантує, що файл буде закритий, навіть якщо в процесі виконання в контекстному блоку 
виникне виключення, і виводить повідомлення про закриття файлу та завершення роботи з ним.

Цей підхід з використанням @contextmanager робить код більш лаконічним і читабельним, 
зберігаючи при цьому всі переваги контекстних менеджерів для управління ресурсами.

Створимо контекстний менеджер, який буде управляти відкриттям та закриттям файлу з 
додатковим логуванням. Наш контекстний менеджер managed_resource буде вимірювати час 
виконання операцій з файлом та логувати дії відкриття і закриття файлу разом з 
тривалістю їх виконання.

from contextlib import contextmanager
from datetime import datetime


@contextmanager
def managed_resource(*args, **kwargs):
    log = ''
    timestamp = datetime.now().timestamp()
    msg = f'{timestamp:<20}|{args[0]:^15}| open \n'
    log += msg
    file_handler = open(*args, **kwargs)
    try:
        yield file_handler
    finally:
        diff = datetime.now().timestamp() - timestamp
        msg = f'{timestamp:<20}|{args[0]:^15}| closed {round(diff, 6):>15}s \n'
        log += msg
        file_handler.close()
        print(log)


with managed_resource('new_file.txt', 'r') as f:
    print(f.read())

Виведення:

Hello world!
The end

1707565076.245372   | new_file.txt  | open 
1707565076.245372   | new_file.txt  | closed        0.004001.

В процесі роботи, перш ніж файл буде відкритий, фіксується поточний час, що дозволяє 
згенерувати лог-повідомлення log про початок операції з файлом. Це повідомлення містить 
мітку часу, ім'я файлу та дію, яка виконується на даному етапі - відкриття файлу.

log = ''
timestamp = datetime.now().timestamp()
msg = f'{timestamp:<20}|{args[0]:^15}| open \n'
log += msg

Після цього файл відкривається з використанням переданих параметрів (ім'я файлу, 
режим відкриття, кодування), і файловий дескриптор повертається у блок with. Це 
дозволяє виконувати різні операції з файлом, наприклад, читання або запис. В нашому 
випадку ми просто читаємо рядки файлу.

file_handler = open(*args, **kwargs)
try:
    yield file_handler

При виході з блоку with виконується фінальна частина коду в рамках методу finally. 
Вона включає логування про закриття файлу, де також фіксується мітка часу і вказується 
тривалість виконання операцій з файлом. Файл закривається, а інформація про весь процес
відкриття, використання та закриття файлу виводиться на екран.

finally:
        diff = datetime.now().timestamp() - timestamp
        msg = f'{timestamp:<20}|{args[0]:^15}| closed {round(diff, 6):>15}s \n'
        log += msg
        file_handler.close()
        print(log)

Таким чином, наш контекстний менеджер не тільки спрощує роботу з файлами, автоматизуючи 
процеси відкриття та закриття, але й забезпечує додаткову користь у вигляді детального 
логування процесів, замість використання звичайного open() . Це може бути досить корисно 
при діагностиці та аналізі продуктивності нашої програми.

1. Що робить об'єкт класу Python, який має метод __call__?

-- Дозволяє об'єктам використовуватися як ітератори.
-- Дозволяє об'єктам зчитувати атрибути з інших об'єктів.
!- Дозволяє об'єктам бути викликаними як функції.
-- Дозволяє об'єктам перевіряти типи аргументів під час виклику.

Так, метод __call__ дозволяє об'єктам класу бути викликаними як функції.

2. Який з методів використовується для отримання наступного елемента під час ітерації об'єкта в Python?

-- __get__()
!- __next__()
-- __fetch__()
-- __retrieve__()

Так, метод __next__() використовується для отримання наступного елемента під час ітерації.

3. Як можна описати ітератор в контексті його використання?

!- Ітератор можна використовувати для послідовного перебору елементів, не завантажуючи всю 
послідовність у пам'ять.
-- Ітератор можна використовувати для одночасного доступу до всіх елементів у послідовності.
-- Ітератори можна використовувати тільки для зчитування даних з файлів.
-- Ітератори використовуються для створення масивів у Python.

Так, ітератори дозволяють послідовно перебирати елементи об'єкта ітерації, не завантажуючи всю 
послідовність у пам'ять, і неможливо повторно перебрати елементи з одного і того ж ітератора.

4. Який спосіб створення ітераторів в Python є спрощеним і автоматично реалізує методи __iter__() 
та __next__()?

-- Використання циклу for.
-- Використання методу iterator().
-- Використання ключового слова iter.
!- Використання генератора з ключовим словом yield.

Використання циклу for, методу iterator() або ключового слова iter не є спрощеним способом 
створення ітераторів з автоматичною реалізацією методів __iter__() та __next__().

5. Який метод використовується для взаємодії з генератором шляхом надсилання значення у генератор?

-- resume()
-- start()
!- send()
-- invoke()

Методи resume(), start() та invoke() не використовуються для взаємодії з генераторами у Python.

6. Які магічні методи необхідно реалізувати для створення власного менеджера контексту в Python?

-- __begin__ і __end__
-- __start__ і __finish__
-- __enter__ і __leave__
!- __enter__ і __exit__

Так, для створення власного менеджера контексту потрібно реалізувати методи __enter__ і __exit__. 
А методи __begin__ і __end__, __start__ і __finish__, __enter__ і __leave__ не використовуються 
для створення власних менеджерів контексту в Python.