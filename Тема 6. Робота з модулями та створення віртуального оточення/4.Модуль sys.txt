Модуль sys. Обробка аргументів командного рядка



Модуль sys в Python є частиною стандартної бібліотеки і надає доступ до деяких змінних та функцій, що взаємодіють із інтерпретатором Python. Модуль sys часто використовується для отримання інформації про середовище, в якому працює програма, і для взаємодії з системою на більш низькому рівні.



Модуль sys забезпечує доступ до змінних і функцій, пов'язаних із самим Python і операційною системою, на якій він встановлений. Цей модуль також містить багато інформації про систему імпорту Python.



Ось декілька ключових можливостей модуля sys:



sys.argv - список аргументів командного рядка, переданих скрипту Python. Елемент argv[0] є ім'ям скрипту, а інші елементи – це додаткові аргументи командного рядка.
sys.exit() - функція виходу з Python. Ви можете передати числовий аргумент, що стане статусом виходу програми. Прийнято, що аргумент 0 означає успішне завершення, а ненульові значення вказують на помилку.
sys.path - список рядків, який визначає шлях пошуку інтерпретатора для модулів. Ви можете модифікувати цей список, щоб додати власні шляхи для пошуку модулів.
sys.version - рядок, що містить інформацію про версію Python, яка використовується.
sys.platform - рядок, що вказує на ім'я платформи, на якій виконується Python (наприклад, 'linux' для Linux, 'win32' для Windows).
sys.modules - словник, який містить завантажені модулі. Ключі – це назви модулів, а значення – це об'єкти модулів.


Перш за все, отримаємо список модулів, імпортованих на даний момент, за допомогою змінної sys.modules. Це словник, де ключ - ім'я модуля, який ви хочете перевірити, а значення, що повертається, - об'єкт модуля.



Наприклад, щойно модуль os імпортовано, можна повернути його значення:



✂️ Цей код можна запустити! 

import sys
import os

print(sys.modules["os"])



Виведення буде шлях, де знаходиться модуль os при виконанні скрипту. В вашому випадку виведення звісно може відрізнятися, все залежить від системи, версії Python тощо:



<module 'os' from 'C:\\Users\\Krabat\\AppData\\Local\\Programs\\Python\\Python310\\lib\\os.py'>



Змінна sys.modules - це звичайний словник Python, у якому розміщуються усі завантажені модулі. Це означає, що, наприклад, виклик sys.modules.keys() поверне повний список імен завантажених модулів.



✂️ Цей код можна запустити! 

import sys
import os

print(sys.modules.keys())



Виведення:

dict_keys(['sys', 'builtins', '_frozen_importlib', '_imp', '_thread', '_warnings', '_weakref', '_io', 'marshal', 'nt', 'winreg', '_frozen_importlib_external', 'time', 'zipimport', '_codecs', 'codecs', 'encodings.aliases', 'encodings', 'encodings.utf_8', 'encodings.cp1251', '_signal', '_abc', 'abc', 'io', '__main__', '_stat', 
'stat', '_collections_abc', 'genericpath', 'ntpath', 'os.path', 'os', '_sitebuiltins', '_distutils_hack', 'pywin32_system32', 'pywin32_bootstrap', 'site'])



Отримати список модулів, вбудованих у мову, можна за допомогою змінної sys.builtin_module_names. Вбудовані модулі, які компілюються в інтерпретатор, залежатимуть від параметрів, переданих під час складання програми.



import sys
import os

print(sys.builtin_module_names)



Виведення:

('_abc', '_ast', '_bisect', '_blake2', '_codecs', '_codecs_cn', '_codecs_hk', '_codecs_iso2022', '_codecs_jp', '_codecs_kr', '_codecs_tw', '_collections', '_contextvars', '_csv', '_datetime', '_functools', '_heapq', '_imp', '_io', '_json', '_locale', '_lsprof', '_md5', '_multibytecodec', '_opcode', '_operator', '_pickle', '_random', '_sha1', '_sha256', '_sha3', '_sha512', '_signal', '_sre', '_stat', '_statistics', '_string', '_struct', '_symtable', '_thread', '_tracemalloc', '_warnings', '_weakref', '_winapi', '_xxsubinterpreters', 'array', 'atexit', 'audioop', 'binascii', 'builtins', 'cmath', 'errno', 'faulthandler', 'gc', 'itertools', 'marshal', 'math', 'mmap', 'msvcrt', 'nt', 'sys', 'time', 'winreg', 'xxsubtype', 'zlib')



Здійснюючи імпорт модуля, Python покладається на список шляхів для його пошуку. Цей список зберігається у змінній sys.path. Щоб перевірити, за якими шляхами інтерпретатор шукатиме модулі, виведіть sys.path.



Можна змінити цей список, додати або прибрати шляхи в міру необхідності. Для звичайного функціонування програми немає необхідності змінювати змінну шляху. Зауважимо, що для пошуку необхідного модуля буде здійснено обхід за списком, тому важливий порядок розташування шляхів у sys.path. Зручно розміщувати шляхи, які з більшою ймовірністю містять шукані модулі, на початку списку для прискорення пошуку. Це також гарантує, що якщо є два модулі з однаковим ім'ям, буде обрано перший із них. Остання властивість має особливе значення через одну поширену помилку: перекриття викликів модулів, вбудованих у Python, власними модулями. На початку імпорту проглядається робоча директорія проєкту, а потім вже стандартна бібліотека. Це означає, що якщо ви назвете свій скрипт random.py і спробуєте виконати import random, то буде імпортовано ваш скрипт, а не бібліотека вбудована в Python.



Коли запускаємо збережений у файлі Python скрипт, є можливість передати йому при запуску якісь аргументи, як у функцію. Тоді наш скрипт може ці аргументи прийняти і якось змінити свою поведінку. Зробити це можна за допомогою пакета sys, в якому є список argv, де з'являються всі аргументи, з якими був запущений скрипт.



Цікавою особливістю sys.argv є те, що першим елементом цього списку буде назва самого файлу скрипту. Всі аргументи будуть у sys.argv у вигляді рядків в тому самому порядку, в якому вони були передані під час виклику. Python розділяє аргументи пробілами і в sys.argv пробіли не потрапляють.



Щоб зрозуміти як працює sys.argv, ви можете зробити простий скрипт echo.py, який буде виводити у консоль всі передані при виклику аргументи.



✂️ Цей код можна запустити! 

import sys

for arg in sys.argv:
    print(arg)



Якщо запустити скрипт echo.py наступною командою:



✂️ Цей код можна запустити! 

 python echo.py test --user -hello some text 



Виведення повинно бути такого вигляду:

echo.py
test
--user
-hello
some
text



Бо при запуску скрипту echo.py Python всі передані аргументи зберіг в списку sys.argv і в нашому випадку він містить список наступних рядків ['echo.py', 'test', '--user', '-hello', 'some', 'text']



Давайте створимо скрипт arg.py, щоб він обробляв перший аргумент запуску:



✂️ Цей код можна запустити! 

import sys

def main():
    if len(sys.argv) > 1:
        print(sys.argv[1])

if __name__ == "__main__":
    main()



Під час виклику такого скрипту командою



✂️ Цей код можна запустити! 

 python arg.py 123 



Ви побачите у консолі 123. Зверніть увагу, що всі елементи списку sys.argv — це завжди рядки. Якщо ви очікуєте, що користувач повинен ввести число (ціле або дробове), то вам потрібно перетворити рядок в потрібний вам тип самостійно. А також завжди перевіряйте, в нашому прикладі if len(sys.argv) > 1:, чи при запуску програми передали необхідну кількість аргументів.



Модуль sys є дуже потужним інструментом для взаємодії з системою та інтерпретатором Python, який надає велику гнучкість при написанні скриптів та програм.