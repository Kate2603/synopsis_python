Структура проєкту

Структура проєкту - це спосіб організації файлів та директорій у вашому проєкті. Вона важлива з кількох причин:

Добре структурований проєкт легше читати та розуміти. Це важливо не тільки для вас, а й для інших 
розробників, які можуть працювати з вашим кодом.
Якщо проєкт має чітку структуру, його легше підтримувати та оновлювати. Нові функції можна додавати більш ефективно.
Коли кілька людей працюють над проєктом, ясна структура допомагає уникнути конфліктів і спрощує спільну роботу.

Структура проєкту є фундаментальними для успішної розробки програмного забезпечення. Вона впливає на багато 
аспектів проєкту, від його розробки до підтримки та розширення. Для новачків в програмуванні важливо зрозуміти
наступні концепції, щоб надалі будувати ефективні, надійні та легкі у підтримці проєкти.

Принцип KISS

Принцип KISS (Keep It Simple, Stupid) — це концепція в дизайні та програмуванні, яка підкреслює важливість 
простоти у розробці. Основна ідея полягає в тому, щоб утримуватись від зайвої складності та зробити рішення 
якомога більш простими та зрозумілими.

Розглянемо основні аспекти принципу KISS:

Простота у дизайні та кодуванні. Код повинен бути легким для читання та розуміння. Це допомагає уникнути 
помилок та спрощує підтримку та модифікацію коду.
Уникнення надмірної складності. Часто інженери мають тенденцію ускладнювати рішення, додаючи додаткові 
функції чи складні архітектури, які насправді не потрібні. Принцип KISS закликає до мінімізації складності.
Використання відомих рішень. Замість вигадування складних нових рішень, варто використовувати випробувані 
та надійні підходи.
Фокусування на ключових функціях. Зосередження на найважливіших аспектах задачі, уникнення додавання 
непотрібних можливостей.

Розглянемо приклад застосування принципу KISS у Python. Порівняємо два підходи до написання функції, 
яка перевіряє, чи є число парним.

Якщо не враховувати принцип KISS то функція могла бути наступного вигляду:

def is_even(number: int) -> bool:
    if number % 2 == 0:
        return True
    else:
        return False

Цей код є коректним та працює, але він містить зайву логіку. Блок else та явне повернення True або 
False не є необхідними. Якщо ми застосуємо принцип KISS то функцію is_even ми запише так:

def is_even(number: int) -> bool:
    return number % 2 == 0

Тут ми спростили функцію, видаливши непотрібну конструкцію if-else. У цій версії коду ми прямо повертаємо 
результат виразу number % 2 == 0, який є True або False. Функція стає коротшою, простішою та легшою для розуміння.

Розглянемо більш складний приклад. Наприклад визначимо чи є рядок паліндромом. Наприклад рядок “Козак з казок” 
є паліндромом бо читається однаково з двох сторін. Функція буде наступного вигляду

✂️ Цей код можна запустити! 

def is_palindrome(s: str) -> bool:
    new_s = ""
		for char in s:
		    if char.isalnum():
		        new_s += char.lower()
		
		s = new_s
    length = len(s)
    for i in range(length // 2):
        if s[i] != s[length - i - 1]:
            return False
    return True

# Використання функції
print(is_palindrome("Козак з казок"))  # Виведе: True

Спочатку ми виконаємо підготовку рядка:

✂️ Цей код можна запустити! 

new_s = ""
for char in s:
    if char.isalnum():
        new_s += char.lower()

s = new_s

Цей код очищає вхідний рядок s від усіх не-алфавітно-цифрових символів та перетворює всі букви на нижній регістр.

Створюється новий порожній рядок new_s.
Цикл for перебирає кожен символ у рядку s.
Якщо символ є буквою або цифрою char.isalnum(), він додається до new_s, попередньо переведений в нижній 
регістр за допомогою char.lower().
Після завершення циклу s присвоюється значення new_s, яке тепер містить тільки алфавітно-цифрові символи у 
нижньому регістрі.

Наш паліндром рядок “Козак з казок” перетвориться на рядок “козакзказок”, ми прибрали всі пробільні символи, 
щоб було легше виконати порівняння на паліндром.

Далі ми виконуємо перевірку на паліндром:

✂️ Цей код можна запустити! 

for i in range(length // 2):
    if s[i] != s[length - i - 1]:
        return False

Цикл for проходить через половину символів рядка, оскільки достатньо перевірити лише половину символів, 
щоб визначити, чи є рядок паліндромом.

s[i] є поточним символом з лівої сторони.
s[length - i - 1] є відповідним символом з правої сторони.
Якщо ці символи не збігаються, рядок точно не є паліндромом, і функція повертає False.

Якщо функція не повернула False під час перевірки усіх відповідних пар символів, це означає, що рядок є 
паліндромом, і функція повертає True.

В принципі, це нормальне робоче рішення для такої задачі. Але насправді цикл для порівняння символів тут 
зайвий. Якщо ви вже зрозуміли цей момент, вітаю ви починаєте бачити принципи KISS. Якщо ні, у вас все ще 
попереду. З застосуванням принципів KISS наш код мав би виглядати наступним чином:

✂️ Цей код можна запустити! 

def is_palindrome(s: str) -> bool:
    new_s = ""
    for char in s:
        if char.isalnum():
            new_s += char.lower()

    s = new_s
    return s == s[::-1]

# Використання функції
print(is_palindrome("Козак з казок"))  # Виведе: True

У цій версії ми спрощуємо код, використовуючи зріз рядка s[::-1], що дозволяє нам отримати рядок у 
зворотному порядку, і просто порівняти його з оригінальним рядком.

Принцип KISS є важливим у програмуванні, оскільки він сприяє створенню коду, який легше підтримувати, 
розширювати та тестувати. Він закликає до мінімізації складності та зосередження на найважливішому, що 
робить програмування ефективнішим та більш доступним.

Принцип DRY

Принцип DRY (Don't Repeat Yourself) закликає розробників уникати повторення однакових частин коду у 
різних частинах програми. Основна мета - зробити код більш ефективним, легким для розуміння та підтримки. 
Повторення коду може призвести до помилок, оскільки при зміні логіки доведеться вносити зміни у кожне 
місце, де цей код використовується.

Розглянемо наступний приклад.

# Розрахунок площі 
length1, width1 = 5, 10
area1 = length1 * width1

# Багато різного коду

length2, width2 = 7, 12
area2 = length2 * width2

У цьому прикладі ми повторюємо логіку розрахунку площі для двох прямокутників. Якщо ми захочемо змінити 
формулу розрахунку, наприклад площа стала трикутною, то нам потрібно буде вносити зміни у двох місцях програми.

Щоб застосувати принцип DRY нам потрібно повторюваний код помістити в функцію.

def calculate_area(length: float, width: float) -> float:
    return length * width

area1 = calculate_area(5, 10)
area2 = calculate_area(7, 12)

Тут ми винесли логіку розрахунку площі в окрему функцію. Це робить код більш читабельним та легшим у 
підтримці. Якщо потрібно буде змінити спосіб розрахунку площі, достатньо буде змінити лише функцію calculate_area, 
а не шукати формулу по всьому коду.

Застосування принципу DRY на рівні модулів дозволяє організувати повторювані функції та класи в окремих 
файлах, з яких вони можуть бути імпортовані та використані в різних частинах програми.

Уявімо, що у нас є модуль math_operations.py, який містить функцію для розрахунку площі прямокутника:

✂️ Цей код можна запустити! 

# math_operations.py
def calculate_area(length, width):
    return length * width

Тепер ми можемо використовувати цю функцію у різних частинах нашої програми, імпортуючи її, а не оголошувати 
функцію calculate_area кожен раз:

✂️ Цей код можна запустити! 

from math_operations import calculate_area

area1 = calculate_area(10, 5)
area2 = calculate_area(20, 15)

Такий підхід знижує ризик помилок при зміні логіки функції, оскільки усі зміни вносяться в одному місці, а 
також спрощує розуміння коду та його підтримку.

Єдина точка входу проєкту

Наш main.py це файл, який є точкою входу для проєкту. Це означає, що коли ми запускаємо проєкт, інтерпретатор 
Python починає виконувати код цього файлу. Це може бути корисним, тому що нам не потрібно запускати кожен 
файл окремо, а можна використовувати одну точку входу для запуску всієї програми.

Щоб об'єднати файли в проєкті, можна імпортувати функції або класи з інших файлів у main.py. Це може 
виглядати так:

from my_module import my_function

def main():
    my_function()

if __name__ == "__main__":
    main()

У цьому прикладі ми імпортуємо функцію my_function з файлу my_module.py і викликаємо її в функції main(). 
Потім ми перевіряємо, чи запущено цей файл як основний скрипт __name__ == "__main__", і якщо так, ми 
запускаємо функцію main(). Це дозволяє використовувати цей файл як модуль для інших скриптів, не 
запускаючи функцію main(), якщо він імпортований як модуль.

Ви повинні використовувати файл main.py для об'єднання та організації вашого коду, наприклад, імпортуючи 
різні класи та функції з різних файлів та використовуючи їх для створення програмного інтерфейсу або для 
запуску різних функцій у певному порядку. Це може допомогти вам зберегти ваш код у порядку і легко знайти 
потрібний код у майбутньому.

Практичний приклад

Ви працюєте з набором даних, який представляє собою температурні показники за кожен день протягом одного 
місяця. Дані зберігаються у текстовому файлі, де кожен рядок відповідає одному дню. Якщо температура за 
день не фіксувалася, відповідний рядок у файлі залишається порожнім.

Необхідно обчислити мінімальну, максимальну, середню температуру та медіану для вказаного набору даних.

Як виконати таку задачу?

Спочатку треба визначити етапи виконання завдання. Логічно, що спочатку треба написати функцію для читання 
температурних показників з файлу. Ми знаємо, що данні в нас мають пусті рядки тож треба буде реалізувати 
функцію для видалення порожніх записів та перетворення рядків у числові значення. Потім необхідно обчислити 
мінімальну, максимальну, середню температуру та медіану для отриманого набору даних. І в кінці розробити 
головну функцію для оркестрації вищезгаданих задач та виведення результатів аналізу.

Отже, план такий:

Завантаження даних
Очищення даних
Обробка та аналіз даних
Вивід результатів

Для вирішення цього завдання ми створимо Python-проєкт, який складається з трьох основних частин: 
завантаження даних у data.py, обробки даних у processing.py та основної логіки програми у main.py.

Дані про температуру будуть зчитуватися з текстового файлу "temperatures.txt", де кожен рядок містить 
одне значення температури або порожній для днів, коли температура не фіксувалася. Для прикладу файл 
матиме наступний вміст:

22.5
23.1
21.8

22.9
23.4

24.1
23.8
24.5

25.0
23.9
23.5
23.0
22.8
24.2

25.1
24.8
25.3
24.6

24.4
25.5
26.1
25.8
26.0
25.6
25.9
26.3

Структура проєкту в нас зараз наступна:

📦example_prj
 ┣ 📜data.py
 ┣ 📜main.py
 ┣ 📜processing.py
 ┗ 📜temperatures.txt

Файл data.py відповідатиме за завантаження та первинну обробку даних.

✂️ Цей код можна запустити! 

def load_data(filename: str) -> list[str]:
    with open(filename, "r") as file:
        return file.readlines()

def clean_data(temperature_data: list[str]) -> list[float]:
    return [float(temp.strip()) for temp in temperature_data if temp.strip()]

Функція load_data читає дані з файлу та повертає список рядків. Функція clean_data виконує очищення даних 
та перетворює рядки в числа і відкидає порожні рядки.

Файл processing.py міститиме логіку обробки даних: обчислення середньої, мінімальної, максимальної та 
медіанної температури.

✂️ Цей код можна запустити! 

def calculate_statistics(temperatures: list[float]) -> dict:
    if not temperatures:
        return None

    min_temp = min(temperatures)
    max_temp = max(temperatures)
    avg_temp = sum(temperatures) / len(temperatures)
    median_temp = calculate_median(temperatures)

    return {
        "min": min_temp,
        "max": max_temp,
        "average": avg_temp,
        "median": median_temp,
    }

def calculate_median(temperatures: list[float]) -> float:
    temperatures.sort()
    n = len(temperatures)
    mid = n // 2
    if n % 2 == 0:
        return (temperatures[mid - 1] + temperatures[mid]) / 2
    else:
        return temperatures[mid]

Тут все досить зрозуміло: для розрахунку середньої, мінімальної та максимальної температури ми 
використовуємо вбудовані функції Python. Функція min повертає найменше значення з набору або з 
послідовності. Це може бути список, кортеж, множина чи будь-який інший ітерований об'єкт. На 
відміну від min, функція max повертає найбільше значення з набору даних або послідовності. 
Функція sum використовується для обчислення суми елементів у послідовності, зазвичай чисел.

Функція calculate_median обчислює медіану для вхідного списку чисел temperatures.

Пояснимо, як вона працює:

Спочатку список temperatures сортується за зростанням.
Потім обчислюється довжина списку n.
Індекс середини списку визначається як mid = n // 2.
Якщо кількість елементів у списку парна n % 2 == 0, медіаною буде середнє арифметичне двох середніх елементів, 
тобто (temperatures[mid - 1] + temperatures[mid]) / 2.
Якщо кількість елементів у списку непарна, медіаною буде елемент у центрі списку, тобто temperatures[mid].

Головний файл main.py використовує функції з data.py та processing.py для виконання завдання.

✂️ Цей код можна запустити! 

from data import load_data, clean_data
from processing import calculate_statistics

def main():
    filename = "temperatures.txt"
    raw_data = load_data(filename)
    temperatures = clean_data(raw_data)
    stats = calculate_statistics(temperatures)

    if stats:
        print(f"Minimum Temperature: {stats['min']}°C")
        print(f"Maximum Temperature: {stats['max']}°C")
        print(f"Average Temperature: {stats['average']:.2f}°C")
        print(f"Median Temperature: {stats['median']:.2f}°C")
    else:
        print("No temperature data available.")

if __name__ == "__main__":
    main()

Запустимо main.py для виконання програми.

Minimum Temperature: 21.8°C
Maximum Temperature: 26.3°C
Average Temperature: 24.38°C
Median Temperature: 24.45°C

Розділення проєкту на окремі файли, такі як main.py, data.py та processing.py, є ефективним підходом до 
структурування коду, що дозволяє чітко визначити різні аспекти програми. Кожен файл в цій структурі 
відповідає за певну частину функціоналу, що сприяє кращому розумінню і управлінню кодом.

Модуль data.py фокусується на завантаженні та обробці вхідних даних. Це робить дані готовими до подальшого 
аналізу та гарантує, що вся логіка, пов'язана з даними, зосереджена в одному місці. Модуль processing.py 
відповідає за обробку та аналіз цих даних, обчислюючи необхідні статистичні показники. Таке розділення 
дозволяє ізолювати обчислювальну логіку від основного потоку програми, що спрощує модифікацію та розширення 
функціоналу в майбутньому. Файл main.py служить як точка входу в програму, зв'язуючи всі модулі разом та 
управляючи загальним потоком виконання.

Це простий приклад, але він демонструє, як ви можете використовувати main.py для об'єднання різних функцій 
та модулів в одному місці та організації вашого коду. Ви можете додавати додаткові функції та модулі до 
вашого проєкту і використовувати main.py для об'єднання їх всього в одному місці. Це допоможе вам зберегти 
ваш код у порядку і легко знайти потрібний код у майбутньому.

Така структура не тільки полегшує розуміння та підтримку коду, але й сприяє перевикористанню компонентів 
у різних частинах програми чи навіть у майбутніх проєктах. Розбивання коду на модулі дозволяє легше 
адаптувати і оновлювати програму, особливо при змінах в даних або вимогах до обробки даних.

Уявіть структуру вашого проєкту як навігацію по веб-сайту, де main.py служить як головна сторінка, з якої 
ви можете переходити до різних секцій або модулів. Кожен модуль функціонує як окрема веб-сторінка, яка 
відповідає за свій унікальний 'розділ' або аспект загальної функціональності програми. Так само, як 
веб-сторінка має свою конкретну роль і зміст, кожен модуль програми виконує певні завдання, створюючи 
чітку та організовану структуру.

