Структури даних: Стек, Черга та Двостороння черга

Структури даних є фундаментальними компонентами програмування, оскільки вони організовують та зберігають дані в комп'ютерних програмах. Серед них, стеки, черги та двосторонні черги (deques) є особливо важливими через їх універсальність та ефективність у вирішенні різноманітних алгоритмічних задач.





Стек

Стек - це одна з фундаментальних структур даних у програмуванні, яка дозволяє здійснювати операції вставки і вилучення даних за принципом "Останнім прийшов - першим вийшов" (LIFO - Last In, First Out).



У структурованому лінійному списку, організованому за принципом LIFO, елементи можуть додаватися та вибиратися тільки з одного кінця, що називається «вершиною списку». Структура LIFO може бути проілюстрована наступним малюнком.






Існують основні операції стеку:



Push - додавання елемента.
Pop - вилучення елемента.
Peek - перегляд верхнього елемента.
Is Empty - перевірка стеку на порожнечу.


Проста реалізація цих команд стеку включає наступні функції:



# Створення стеку
def create_stack():
    return []

# Перевірка на порожнечу
def is_empty(stack):
    return len(stack) == 0

# Додавання елементу
def push(stack, item):
    stack.append(item)

# Вилучення елементу
def pop(stack):
    if not is_empty(stack):
        return stack.pop()
    else:
        print("Стек порожній")

# Перегляд верхнього елемента
def peek(stack):
    if not is_empty(stack):
        return stack[-1]
    else:
        print("Стек порожній")



Спочатку створимо стек та додамо декілька елементів:

stack = create_stack()
push(stack, 'a')
push(stack, 'b')
push(stack, 'c')



Тепер стек містить елементи ['a', 'b', 'c'], де 'c' є на вершині стеку.



Переглянемо верхній елемент:

print(peek(stack))  # Виведе 'c'



Видалимо верхній елемент:

print(pop(stack))  # Виведе 'c'



Тепер стек містить ['a', 'b']. Якщо ми спробуємо знову переглянути або видалити верхній елемент, ми отримаємо 'b'.



Якщо ми продовжимо видаляти елементи, поки стек не стане порожнім, а потім спробуємо ще раз видалити або переглянути верхній елемент, обидві функції pop() та peek() виведуть повідомлення "Стек порожній".



Стеки в програмуванні є ідеальними для задач, де потрібно відслідковувати елементи в зворотному порядку. Наприклад, стеки застосовуються в управлінні викликами функцій та в різноманітних алгоритмах.





Черга

Черга (queue) у програмуванні — це абстрактна структура даних, яка діє за принципом "перший прийшов – перший вийшов" (FIFO: First In, First Out). Елементи додаються (enqueue) на один кінець структури та видаляються (dequeue) з іншого кінця.






Існують основні операції для черги:



Enqueue - додавання елемента в кінець черги.
Dequeue - видалення елемента з початку черги.
Front/Peek - перегляд першого елемента черги без його видалення.
Is Empty - перевірка, чи черга порожня.
Size - визначення кількості елементів у черзі.


Черги широко використовуються в програмуванні для управління потоками даних та завдань, особливо коли порядок елементів має значення.



В Python, чергу можна реалізувати за допомогою вбудованого типу list, хоча це не завжди найефективніший спосіб через високу вартість операцій Dequeue. Списки у Python реалізовані таким чином, що вибір елемента за індексом відбувається за константний час (дуже швидко) і додавання/видалення елементу з кінця списку теж відбувається дуже швидко. Але ось додавання елементу в будь-яке інше місце в списку змушує Python перерахувати індекси усіх елементів списку до кінця. Для великих списків це може бути дуже невигідно. Ефективнішим варіантом є використання deque з модуля collections в якості черги.



✂️ Цей код можна запустити!

from collections import deque

# Створення черги
queue = deque()

# Enqueue: Додавання елементів
queue.append('a')
queue.append('b')
queue.append('c')

print("Черга після додавання елементів:", list(queue))

# Dequeue: Видалення елемента
print("Видалений елемент:", queue.popleft())

print("Черга після видалення елемента:", list(queue))

# Peek: Перегляд першого елемента
print("Перший елемент у черзі:", queue[0])

# IsEmpty: Перевірка на порожнечу
print("Чи черга порожня:", len(queue) == 0)

# Size: Розмір черги
print("Розмір черги:", len(queue))



Виведення:

Черга після додавання елементів: ['a', 'b', 'c']
Видалений елемент: a
Черга після видалення елемента: ['b', 'c']
Перший елемент у черзі: b
Чи черга порожня: False
Розмір черги: 2



У цьому прикладі ми використовуємо deque для створення черги, що дозволяє нам ефективно додавати елементи в кінець черги (Enqueue) і видаляти елементи з початку (Dequeue). Операція popleft() використовується для Dequeue, оскільки вона видаляє перший елемент з deque, відповідаючи поведінці FIFO черги.



Черги, застосовують для задач, де елементи повинні бути оброблені в порядку їх надходження. Вони широко застосовуються для управління задачами в операційних системах, у системах черги повідомлень для мікросервісів, а також у графічних інтерфейсах для управління подіями.





Двостороння черга deque

Двостороння черга, або Deque (скорочення від "double-ended queue"), є типом структури даних, яка дозволяє вставляти та видаляти елементи з обох кінців. Ця гнучкість робить Deque особливо корисною у багатьох сценаріях програмування.






На відміну від звичайної черги, де елементи можна додавати та видаляти лише з одного кінця, Deque дозволяє проводити операції на обох кінцях. Тому deque з модуля collections реалізований таким чином, що операції додавання та видалення елементів є дуже ефективними, навіть для великих наборів даних.



Основні методи deque



append(x) - додає елемент x в кінець черги.
appendleft(x) - додає елемент x на початок черги.
pop() - видаляє та повертає елемент з правого кінця черги. Якщо черга порожня, викидає виняток IndexError.
popleft() - видаляє та повертає елемент з лівого кінця черги. Якщо черга порожня, викидає виняток IndexError.


✂️ Цей код можна запустити!

from collections import deque

# Створення пустої двосторонньої черги
d = deque()

# Додаємо елементи в чергу
d.append('middle')  # Додаємо 'middle' в кінець черги
d.append('last')    # Додаємо 'last' в кінець черги
d.appendleft('first')  # Додаємо 'first' на початок черги

# Виведення поточного стану черги
print("Черга після додавання елементів:", list(d))

# Видалення та виведення останнього елемента (з правого кінця)
print("Видалений останній елемент:", d.pop())

# Видалення та виведення першого елемента (з лівого кінця)
print("Видалений перший елемент:", d.popleft())

# Виведення поточного стану черги після видалення елементів
print("Черга після видалення елементів:", list(d))



Виведення:

Черга після додавання елементів: ['first', 'middle', 'last']
Видалений останній елемент: last
Видалений перший елемент: first
Черга після видалення елементів: ['middle']



Ще однією особливістю deque є можливість обмежити розмір Deque:



✂️ Цей код можна запустити!

from collections import deque

d = deque(maxlen=5)
for i in range(10):
    d.append(i)

print(d)



Виведення:

deque([5, 6, 7, 8, 9], maxlen=5)



Як видно з прикладу, нові елементи витісняють старіші, але розмір залишається незмінним. В усьому іншому deque веде себе точно як список Python.



Двосторонні черги поєднують в собі можливості стеків та черг, дозволяючи додавати та видаляти елементи з обох кінців. Це робить їх виключно гнучкими для різних сценаріїв. Deques часто використовуються там, де потрібен швидкий доступ до елементів з обох кінців структури, наприклад, в алгоритмах, що вимагають обробки буферів або паліндромів, а також у задачах з різними пріоритетами.



Уявімо, що у нас є список завдань на день, де кожне завдання описано як словник із двома атрибутами: тип завдання (швидке або повільне) та його назва. Наша задача — розподілити ці завдання таким чином, щоб швидкі завдання виконувалися першими. Для цього ми використаємо двосторонню чергу, яка дозволяє нам додавати елементи як на початок, так і в кінець черги.



tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]



Завдання, визначені як "fast", повинні виконуватися в першу чергу, тому вони мають більший пріоритет. Натомість "slow" завдання можуть зачекати і ми додаємо їх в кінець черги, виконуючи після всіх швидких завдань.



Мета цієї задачі — продемонструвати, як можна використовувати двосторонню чергу для контролю пріоритету завдань.



✂️ Цей код можна запустити!

from collections import deque

# Список завдань, де кожне завдання - це словник
tasks = [
    {"type": "fast", "name": "Помити посуд"},
    {"type": "slow", "name": "Подивитись серіал"},
    {"type": "fast", "name": "Вигуляти собаку"},
    {"type": "slow", "name": "Почитати книгу"}
]

# Ініціалізація черги завдань
task_queue = deque()

# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")

# Виконання завдань
while task_queue:
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")



Розглянемо як розв'язана ця задача. Отже створюється порожня двостороння черга для зберігання завдань.



# Ініціалізація черги завдань
task_queue = deque()



Потім ми виконуємо розподіл завдань за пріоритетом.



Проходимося по кожному завданню в списку.
Якщо тип завдання "fast" (швидке), додаємо його на початок черги, надаючи йому високий пріоритет.
Якщо тип завдання "slow" (повільне), додаємо його в кінець черги, надаючи нижчий пріоритет.


# Розподіл завдань у чергу відповідно до їх пріоритету
for task in tasks:
    if task["type"] == "fast":
        task_queue.appendleft(task)  # Додавання на високий пріоритет
        print(f"Додано швидке завдання: {task['name']}")
    else:
        task_queue.append(task)  # Додавання на низький пріоритет
        print(f"Додано повільне завдання: {task['name']}")



Далі блок виконання завдань. Допоки в черзі є завдання, витягуємо завдання з початку черги (з лівого кінця). Виконуємо завдання в порядку їх пріоритету: спочатку всі швидкі, потім повільні.



# Виконання завдань
while task_queue:
    task = task_queue.popleft()
    print(f"Виконується завдання: {task['name']}")



Швидкі завдання отримують перевагу, оскільки вони додаються на передню частину черги та виконуються першими. Повільні завдання, додані в кінець черги та чекають, поки не будуть виконані всі швидкі завдання. Що і демонструє процес виведення:



Додано швидке завдання: Помити посуд
Додано повільне завдання: Подивитись серіал
Додано швидке завдання: Вигуляти собаку
Додано повільне завдання: Почитати книгу
Виконується завдання: Вигуляти собаку
Виконується завдання: Помити посуд
Виконується завдання: Подивитись серіал
Виконується завдання: Почитати книгу



Звичайно все, це можна було зробити за допомогою звичайних списків. Використання deque замість звичайного списку для управління завданнями забезпечує більшу ефективність, особливо при частих операціях вставки та видалення на обох кінцях структури. На відміну від звичайних списків, де такі операції можуть бути повільними, особливо на початку списку, deque оптимізована для швидких вставок та видалень, що робить її ідеальною для задач, де потрібно динамічно керувати елементами з високим та низьким пріоритетом.