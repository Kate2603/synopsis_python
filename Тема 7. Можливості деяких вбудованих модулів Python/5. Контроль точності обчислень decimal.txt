Контроль точності обчислень decimal



Комп'ютер усі обчислення робить в бінарному вигляді, а десяткові числа використовуються тільки для "спілкування" з користувачем для зручності останнього. Через це і через те, що точність обчислень в комп'ютері обмежена, виникають помилки округлення під час виконання математичних операцій.



Наприклад виконаємо наступний код:



print(0.1 + 0.2 == 0.3)
print(0.1 + 0.2)



Виведення:



False
0.30000000000000004



Перший вираз може збити вас з пантелику, оскільки математика стверджує однозначно, що 0.1 + 0.2 = 0.3. Але помилка округлення під час виконання обчислювальних операцій з дійсними числами у двійковій системі обчислення призводить до такої неоднозначності.



Щоб контролювати точність обчислень більш явно, у Python є пакет decimal. Decimal — це клас у модулі decimal, який забезпечує точну арифметику з дійсними числами, вирішуючи деякі проблеми, які виникають при використанні типу float. Він особливо корисний для точних обчислень, таких як фінансові розрахунки, де помилки округлення можуть призвести до значних проблем.



Переднє обчислення ми можемо виконати тепер так:



✂️ Цей код можна запустити!

from decimal import Decimal

print(Decimal("0.1") + Decimal("0.2") == Decimal("0.3"))
print(Decimal("0.1") + Decimal("0.2"))



Виведення:

True
0.3



Об'єкти Decimal поводяться так само, як float, але їх і не можна використовувати в одному виразі разом. Виконання виразу на кшталт Decimal("0.1") + 0.2 призведе до помилки.



Точність обчислень з Decimal контролюється через контекст. Можна налаштувати загальну точність для всіх обчислень Decimal.



from decimal import getcontext
getcontext().prec = 4



Тепер будь-які обчислення з Decimal будуть мати точність до чотирьох знаків після коми.



from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("1") / Decimal("7"))

getcontext().prec = 8
print(Decimal("1") / Decimal("7"))



У цьому прикладі ми вирахували вираз 1 / 7 з точністю до 6 і 8 знаків після коми відповідно. Щоб встановити точність обчислення, ми скористалися функцією getcontext, яка повертає поточні налаштування точності, та встановили налаштування prec у 6 та 8 відповідно.



Виведення:

0.142857
0.14285714



Зверніть увагу, що ми кажемо саме до знаків після коми. Бо getcontext встановлює кількість значущих цифр. А значущими числами можуть бути і цифри перед комою.



☝ Визначення значущих цифр:

Усі ненульові цифри є значущими: 1, 2, 3, 4, 5, 6, 7, 8, 9.
Нулі між ненульовими цифрами значущі: 102, 2005, 50009.
Провідні нулі ніколи не бувають значущими: 0.02; 001.887; 0.000515.
В числі з десятковою або без десяткової крапки знаходяться знакові нулі (праворуч від останньої ненульової цифри) за умови, якщо вони обґрунтовані точністю їх використання: 389.000; 2.02000; 5.400; 57.5400. 


Більш докладно може прочитати про значущі цифри на wiki.



from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal("233") / Decimal("7"))



Виведення буде саме 6 значущих цифр.

33.2857



Якщо ми потребуємо саме округлення чисел, нам необхідно використовувати метод quantize. Метод quantize використовується для встановлення точності числа Decimal, заснованої на іншому числі Decimal, яке використовується як шаблон.



Наприклад, якщо ви хочете округлити число до двох знаків після коми, ви використовуєте Decimal об'єкт з двома нулями після коми як шаблон.



✂️ Цей код можна запустити!

from decimal import Decimal, ROUND_DOWN

# Вихідне число Decimal
number = Decimal('3.14159')

# Встановлення точності до двох знаків після коми
rounded_number = number.quantize(Decimal('0.00'), rounding=ROUND_DOWN)

print(rounded_number)



У цьому прикладі число 3.14159 округляється до 3.14 з використанням методу quantize, де як шаблон для точності використовується Decimal('0.00'), а режим округлення встановлено як rounding=ROUND_DOWN.



Decimal дозволяє вибирати різні режими округлення. Згідно з офіційною документацією Python, розглянемо основні режими:



ROUND_FLOOR число завжди округляє до найближчого меншого значення, незалежно від знаку числа.
ROUND_CEILING число завжди округляє до найближчого більшого значення, незалежно від знаку числа.
ROUND_HALF_DOWN числа округлюються до найближчого значення. У випадку, коли число знаходиться точно посередині між двома можливими варіантами округлення (наприклад, 2.5, де можливі варіанти — 2 або 3), число округляється вниз, тобто до найближчого меншого значення.
ROUND_HALF_UP числа округлюються до найближчого значення. Проте у випадку нічиї (коли число знаходиться точно посередині між двома варіантами), число округляється вгору, тобто до найближчого більшого значення.
ROUND_UP число округляється від нуля. Це означає, що додатні числа округлюються до більшого, а від'ємні - до меншого за модулем значення.
ROUND_DOWN число округляється до нуля. Тобто додатні числа округлюються до меншого, а від'ємні - до більшого за модулем значення.
ROUND_HALF_EVEN числа округлюються до найближчого числа. Цей режим, також відомий як "банківське округлення", округлює число до найближчого значення, але у випадку нічиї (коли число точно посередині між двома варіантами), воно округляється до найближчого парного цілого числа. Наприклад, як 2.5 округлиться до 2, а 3.5 - до 4. Цей метод зменшує сукупну помилку при серії округлень.


За замовчуванням округлення описується константою ROUND_HALF_EVEN



✂️ Цей код можна запустити!

import decimal
from decimal import Decimal
 
number = Decimal("1.45")

# Округлення за замовчуванням до одного десяткового знаку
print("Округлення за замовчуванням ROUND_HALF_EVEN:", number.quantize(Decimal("0.0")))

# Округлення вверх при нічиї (ROUND_HALF_UP)
print("Округлення вгору ROUND_HALF_UP:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_HALF_UP))

# Округлення вниз (ROUND_FLOOR)
print("Округлення вниз ROUND_FLOOR:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_FLOOR))

# Округлення вверх (ROUND_CEILING)
print("Округлення вгору ROUND_CEILING:", number.quantize(Decimal("0.0"), rounding=decimal.ROUND_CEILING))

# Округлення до трьох десяткових знаків за замовчуванням
print("Округлення до трьох десяткових знаків:", Decimal("3.14159").quantize(Decimal("0.000")))



Виведення:

Округлення за замовчуванням ROUND_HALF_EVEN: 1.4
Округлення вгору ROUND_HALF_UP: 1.5
Округлення вниз ROUND_FLOOR: 1.4
Округлення вгору ROUND_CEILING: 1.5
Округлення до трьох десяткових знаків: 3.142



Метод quantize часто використовується у фінансових додатках, де необхідно точно контролювати кількість знаків після коми, особливо при розрахунках, які вимагають строгого дотримання певних правил округлення. Це забезпечує точність і відповідність вимогам, які можуть бути встановлені законодавством або стандартами обліку.



Сам же Decimal — це потужний інструмент для точних обчислень, який надає високий рівень контролю та гнучкості. Його використання є критично важливим у фінансових додатках, бухгалтерському обліку та інших областях, де помилки округлення можуть призводити до серйозних наслідків.