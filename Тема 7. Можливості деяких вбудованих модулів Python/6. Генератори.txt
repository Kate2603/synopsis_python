Генератори

Функції — це ізольовані набори інструкцій з однією точкою входу і однією точкою виходу. Іншими словами, коли ви викликаєте функцію, то інтерпретатор виконає увесь її код від початку і до кінця при кожному виклику.



Але, що якщо потрібно отримати такий ізольований набір інструкцій з декількома точками входу? Або, що якщо ми хочемо продовжити виконання функції з якогось місця при наступному її виклику?



Прикладом таких ситуацій може слугувати генератор випадкових чисел, який при кожному виклику видає нове "випадкове" число і не повторює вже виданих. Або, коли нам потрібна велика послідовність, яку можна легко обчислити але дуже невигідно зберігати в пам'яті повністю.



Подібні завдання у Python вирішують генератори. Один із способів створити генератор у Python — це створити особливу функцію з декількома точками входу. Для цього використовується ключове слово yield.



Оператор yield поводиться схожим чином з return, повертає управління потоком виконання програмою з тіла функції. Але, на відміну від return, yield при наступному зверненні не розпочинає виконання функції з початку, а продовжує з місця зупинки функції.



Звичайно така поведінка припускає, що десь в пам'яті програми повинна зберігатися інформація про те, на чому виконання функції зупинилося і про стан локального простору імен функції. Розглянемо наступний приклад:



✂️ Цей код можна запустити!

def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

# Використання next()
print(next(gen))  # Виведе 1
print(next(gen))  # Виведе 2
print(next(gen))  # Виведе 3



Виведення:

1
2
3



Цей код демонструє основні принципи роботи генератора в Python. Функція my_generator визначена як генератор. Вона використовує ключове слово yield, що вказує на те, що ця функція повертатиме генератор. Коли функція викликає yield, вона "віддає" значення, яке слідує за yield, і "заморожує" свій поточний стан. Виконання функції буде продовжено з цього місця при наступному виклику. Коли ми виконуємо присвоювання gen = my_generator(), то змінна gen тепер є генератором, що повернула функція my_generator.



Далі йде використання next(). При кожному виклику next(gen), генератор продовжує виконання з місця, де він зупинився останнім разом (після yield). При першому виклику next(gen), генератор виконується від початку до першого yield, тобто повертає 1. При другому виклику next(gen), він продовжує від другого yield і повертає 2. При третьому виклику next(gen), він продовжує до третього yield і повертає 3. Код print(next(gen)) виводить значення, яке повертає генератор на кожному кроці.



Після того, як генератор повернув усі свої значення, якщо ми виконаємо виклик next(gen), то виникне виняток StopIteration, оскільки більше немає значень для повернення. Цей виняток є сигналом того, що ітерація завершилася.



Щоб кожен раз не використовувати try except для контролю винятку StopIteration найчастіше генератори використовуються безпосередньо в циклах for ..., який буде це виконувати за нас:



def count_down(start):
    while start > 0:
        yield start
        start -= 1

for number in count_down(5):
    print(number)



Результат виконання цього коду буде.

5
4
3
2
1



☝ Ми вже стикалися з генераторами у Python, це функція range, яка є типовим генератором.


Один з корисних випадків застосування генератору, це ітерація по файлу. Генератор дозволяє нам оброблювати дуже великі файли і при цьому економити пам'ять.



def read_lines(file_path):
    with open(file_path, 'r', encoding="utf-8") as file:
        for line in file:
            yield line.strip()

# Використання генератора для читання рядків з файлу
for line in read_lines("my_file.txt"):
    print(line)



В середині функції read_lines цикл for ітерується по кожному рядку у файлі. Ключове слово yield використовується для повернення кожного рядка файлу. Попередньо кожен рядок оброблено методом strip(), щоб видалити пробіли та символів нового рядка по краях. Це поширена практика очищення даних.



Далі ми просто використовуємо генератор для безпосередньої роботи з рядками файлу.



for line in read_lines("my_file.txt"):
    print(line)



Перевага такого підходу в тому, що завдяки лінивій обробці, генератор читає рядки один за одним, не завантажуючи весь файл у пам'ять. Це особливо корисно при роботі з великими файлами.





Отже зробимо підсумок.


Генератор в Python - це об'єкт, який використовується для лінивої (on-demand) генерації даних та дозволяє нам оголошувати функцію, яка може бути використана в циклі.



Генератор створюється за допомогою функції, яка повертає послідовність елементів один за одним, використовуючи yield, а не return.



Генератор виробляє елементи "на льоту" і обробляє один елемент за раз. Це дуже ефективно з точки зору використання пам'яті, особливо для великих даних. Коли генератор виробляє значення, його стан "заморожується", і виконання може бути продовжене з цього моменту при наступному виклику.



Генератори можна перебирати в циклі for або вручну за допомогою функції next().

1. Який метод використовується для створення іменованих кортежів у модулі collections?

-- create_namedtuple
-- tuple
!- namedtuple
-- make_tuple

Вірно! Метод namedtuple використовується для створення іменованих кортежів.

2. Яка структура даних модуля collections забезпечує підрахунок кількості елементів?

-- dict
!- Counter
-- count_elements
-- ListCounter

Вірно! Counter допомагає в підрахунку кількості елементів.

3. Яка основна перевага defaultdict порівняно із звичайним словником?

!- Автоматичне створення значень для нових ключів
-- Швидше видалення елементів словника
-- Менший розмір в пам'яті
-- Підтримка більшої кількості типів даних

Вірно! defaultdict автоматично створює значення для нових ключів.

4. Який метод використовується для видалення елемента з лівого кінця в черзі deque?

-- pop()
!- popleft()
-- remove_left()
-- delete_first()

Вірно! popleft() видаляє елемент з лівого кінця черги.

5. Який клас використовується для точних обчислень з дійсними числами в Python?

-- PreciseNumber
-- Float
!- Decimal
-- RealNumber

Вірно! Decimal клас використовується для точних обчислень з дійсними числами.

6. Який метод Counter використовується для отримання елементів, що зустрічаються найчастіше?

!- highest_count()
-- frequent_elements()
-- top_elements()
-- most_common()

Неправильно. Метод most_common() з Counter використовується для виявлення елементів, що найбільш часто зустрічаються.

7. Як називається операція додавання елемента в двосторонню чергу deque з лівого кінця?

-- leftappend()
-- prepend()
!- appendleft()
-- pushleft()

Вірно! appendleft() використовується для додавання елемента з лівого кінця в deque.

8. Яка назва методу використовується зазвичай для перевірки на порожнечу стеку?

!- is_empty()
-- empty_check()
-- check_empty()
-- isEmpty()

Вірно! Зазвичай використовується назва методу is_empty() для перевірки стеку на порожнечу.

9. Який метод deque використовується для додавання елемента в кінець двосторонньої черги?

-- enqueue()
-- push_back()
-- insert_end()
!- append()

Вірно! append() використовується для додавання елемента в кінець черги deque.

10. Що робить оператор yield у Python генераторі?

-- Завершує функцію
-- Починає функцію
!- Зберігає стан функції
-- Ігнорує стан функції

Вірно! Оператор yield зберігає стан функції та призупиняє її виконання, зберігаючи місце, де вона зупинилася.