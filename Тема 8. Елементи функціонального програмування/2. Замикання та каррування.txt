Замикання та каррування

Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно, дає можливість використати механізм замикань у Python.



Замикання (closure) в програмуванні — це потужна концепція, особливо в мовах, що підтримують функції вищого порядку, як наприклад Python. Замикання відбувається, коли внутрішня функція запам'ятовує стан свого оточення в момент свого створення і може використовувати ці змінні навіть після того, як зовнішня функція завершила своє виконання.



Ключовими аспектами замикань є:

Внутрішня функція має доступ до змінних, визначених у області видимості зовнішньої функції.
Зовнішня функція повертає внутрішню функцію як результат своєї роботи.
Після завершення роботи зовнішньої функції, внутрішня функція зберігає доступ до цих змінних, що відіграє важливу роль у певних програмних патернах та алгоритмах.


Найпростіше це пояснити на прикладі:



✂️ Цей код можна запустити!

def outer_function(msg):
    message = msg

    def inner_function():
        print(message)

    return inner_function

# Створення замикання
my_func = outer_function("Hello, world!")
my_func()



У цьому прикладі функція outer_function визначена таким чином, що приймає аргумент msg і створює внутрішню змінну message, значення якої ініціалізується переданим аргументом. Усередині outer_function розміщена інша функція, inner_function, яка призначена для виведення на екран значення змінної message. Важливим аспектом є те, що inner_function використовує змінну message, яка була визначена у зовнішньому лексичному середовищі outer_function.



Після виконання outer_function, замість того, щоб безпосередньо викликати inner_function, outer_function повертає її як об'єкт. Це дозволяє функції inner_function зберегти зв'язок зі своїм лексичним середовищем, навіть після завершення виконання outer_function.



Коли виконується дія my_func = outer_function("Hello, world!"), то функція my_func становиться посиланням на функцію inner_function. Чому? Тому, що коли викликається функція outer_function, вона повертає посилання на функцію inner_function. Далі коли ми викликаємо my_func() виконується насправді саме функція inner_function , вона успішно виводить "Hello, world!". Це відбувається завдяки збереженню inner_function доступу до змінної message, що була визначена в outer_function. Така поведінка є класичним прикладом замикання, де внутрішня функція зберігає стан змінних зі свого лексичного контексту.



Як практично це можна використовувати? Насправді досить багато де використовується замикання, але розглянемо більш зрозумілий для початківця приклад. Ми створимо замикання, яке буде зберігати інформацію про кількість разів виклику функції.



✂️ Цей код можна запустити!

from typing import Callable

def counter() -> Callable[[], int]:
    count = 0

    def increment() -> int:
        # використовуємо nonlocal, щоб змінити змінну в замиканні
        nonlocal count  
        count += 1
        return count

    return increment

# Створення лічильника
count_calls = counter()

# Виклики лічильника
print(count_calls())  # Виведе 1
print(count_calls())  # Виведе 2
print(count_calls())  # Виведе 3



Це приклад замикання, де increment замкнула в собі змінну count і має до неї доступ навіть після того, як зовнішня функція counter завершує своє виконання. Завдяки цьому, count_calls зберігає стан між викликами. Кожен раз, коли ми викликаємо count_calls, вона викликає increment, яка замкнула в собі count.



1
2
3



Так можна створити функцію, яка може змінювати поведінку в залежності від того скільки викликів вже відбулося.



Каррінг (currying) — це техніка в програмуванні, коли функція, яка приймає кілька аргументів, перетворюється на послідовність функцій, кожна з яких приймає один аргумент. Названа на честь логіка Гаскеля Каррі, каррінг дозволяє зробити функції більш гнучкими і сприяє створенню високо модульного та читабельного коду.



Припустимо, у нас є функція, яка приймає два аргументи:



def add(a, b):
    return a + b



Застосувавши каррінг до цієї функції, ми перетворимо її на двій функції, кожна з яких приймає по одному аргументу:



def add(a):
    def add_b(b):
        return a + b
    return add_b

# Використання:
add_5 = add(5)
result = add_5(10)
print(result)



Тут функція add приймає перший аргумент a і повертає функцію add_b. Сама функція add_b приймає другий аргумент b і повертає результат a + b. Фактично ми перетворили виклик функції add на виклик двох функцій.



В функціональному програмуванні такий підхід дозволяє легко використати функцію знову і створювати нові функції на базі існуючих. Після того як ми розглянули саму техніку каррінгу давайте подивимось на якийсь практичний приклад використання.



Припустимо, у нас є функція для обчислення знижки на товар. Ця функція приймає відсоток знижки і остаточну ціну товару.



def apply_discount(price: float, discount_percentage: int) -> float:
    return price * (1 - discount_percentage / 100)

# Використання
discounted_price = apply_discount(500, 10)  # Знижка 10% на ціну 500
print(discounted_price)

discounted_price = apply_discount(500, 20)  # Знижка 20% на ціну 500
print(discounted_price)



Виведення:

450.0
400.0



Використовуючи каррінг, ми можемо створити більш гнучку структуру для роботи з різними типами знижок.



Перетворимо функцію apply_discount, використовуючи каррінг. Це дозволить нам створити "замовлені" функції для різних рівнів знижок, кожна з яких буде приймати тільки ціну товару.



✂️ Цей код можна запустити!

from typing import Callable

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Каррінг в дії
ten_percent_discount = discount(10)
twenty_percent_discount = discount(20)

# Застосування знижок
discounted_price = ten_percent_discount(500)  # 450.0
print(discounted_price)

discounted_price = twenty_percent_discount(500)  # 400.0
print(discounted_price)



Виведення:

450.0
400.0



Таким чином, за допомогою каррінгу, ми розділили функцію на дві частини. Спочатку ми створюємо функції з певним відсотком знижки ten_percent_discount та twenty_percent_discount, а потім використовуємо ці функції для обчислення зниженої ціни. Це робить код більш гнучким і дозволяє легко створювати функції для різних рівнів знижок.



Ми можемо піти далі та створити словник, де ключами будуть назви знижок, а значеннями — відповідні функції обчислення знижки, створені за допомогою каррінгу. Це дозволить нам легко вибирати потрібну функцію знижки зі словника.



✂️ Цей код можна запустити!

from typing import Callable, Dict

def discount(discount_percentage: int) -> Callable[[float], float]:
    def apply_discount(price: float) -> float:
        return price * (1 - discount_percentage / 100)
    return apply_discount

# Створення словника з функціями знижок
discount_functions: Dict[str, Callable] = {
    "10%": discount(10),
    "20%": discount(20),
    "30%": discount(30)
}

# Використання функції зі словника
price = 500
discount_type = "20%"

discounted_price = discount_functions[discount_type](price)
print(f"Ціна зі знижкою {discount_type}: {discounted_price}")



Ми створюємо словник discount_functions, де кожному типу знижки "10%", "20%" та "30%" відповідає функція з каррінгом, що обчислює знижку. І тепер щоб застосувати знижку, ми вибираємо потрібну функцію зі словника за допомогою ключа discount_type і передаємо їй ціну товару. Виведення:



Ціна зі знижкою 20%: 400.0



Цей підхід забезпечує велику гнучкість, бо ми можемо легко додавати, видаляти або змінювати знижки в словнику без необхідності зміни основного коду програми.