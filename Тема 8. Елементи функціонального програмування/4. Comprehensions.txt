Comprehensions

В програмуванні досить часто необхідно створити заповнену колекцію. Зробити це одним виразом не можна, 
доводиться писати цикл. Наприклад, щоб створити список квадратів чисел від 1 до 5, треба написати наступний код:

sq = []
for i in range(1, 6):
    sq.append(i**2)

print(sq)

Виведення:

[1, 4, 9, 16, 25]

Подібні операції, які ми робимо зі змінюваними колекціями списків list, словників dict та множин set 
у циклі for. Для спрощення таких операцій в Python ввели конструкції Comprehensions .

Comprehensions в Python - це спосіб компактного створення колекцій на основі існуючих колекцій. Python 
підтримує кілька видів comprehensions: для списків (list comprehensions), множин (set comprehensions) 
та словників (dictionary comprehensions). Вони дозволяють писати вирази для створення нових колекцій з 
меншою кількістю коду, ніж при використанні циклів.

List Comprehensions

List comprehensions використовуються для створення нових списків та мають наступний синтаксис:

[new_item for item in iterable if condition]

Як це виглядає на практиці? Ну, наприклад, попередній приклад можна записати наступним чином:

sq = [x**2 for x in range(1, 6)]
print(sq)

Створення списку квадратів чисел від 1 до 5:

[1, 4, 9, 16, 25]

Умова в синтаксисі дозволяє нам створювати списки за якоюсь умовою. Створимо список квадратів парних чисел від 1 до 9:

even_squares = [x**2 for x in range(1, 10) if x % 2 == 0]
print(even_squares)

У цьому прикладі if x % 2 == 0 є умовою, яка перевіряє, чи є число парним.

[4, 16, 36, 64]

В звичайному стилі попередній приклад прийшлось би записувати так:

even_squares = []
for x in range(1, 10):
    if x % 2 == 0:
        even_squares.append(x**2)

print(even_squares)  # Виведе [4, 16, 36, 64]

У цьому коді використовується цикл for для ітерації чисел від 1 до 9. Для кожного числа x перевіряється, 
чи є воно парним, тобто чи ділиться на 2 без залишку. Якщо так, його квадрат додається до списку even_squares. 
На виході ми отримуємо список квадратів усіх парних чисел у заданому діапазоні. Скільки коду вийшло, замість 
одного рядка Comprehensions цілих чотири!

Як бачимо Comprehensions зазвичай коротші та легші для розуміння, ніж еквівалентні цикли. Але головне 
вони часто більш ефективні за цикли через оптимізації в Python.
