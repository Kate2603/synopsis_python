Декоратори



Є такий шаблон проектування — декоратор. Цей шаблон полягає в тому, щоб розширювати функціонал який вже існує, не вносячи змін в код цього самого функціоналу.



Декоратори в Python — це дуже потужний і корисний інструмент, який дозволяє змінювати поведінку функцій або методів без зміни їхнього вихідного коду. Вони є прикладом функцій вищого порядку, які приймають іншу функцію як аргумент та повертають нову функцію.



Наприклад, у нас є якась дуже складна і важлива функція complicated:



def complicated(x: int, y: int) -> int:
    return x + y



І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логування до цієї функції, виводити в консоль щоразу, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.



Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:



✂️ Цей код можна запустити!

def complicated(x: int, y: int) -> int:
    return x + y

def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

complicated = logger(complicated)
print(complicated(2, 3))



Декоратор logger приймає функцію як аргумент і повертає нову функцію complicated = logger(complicated). Декорована функція зберігає свою оригінальну функціональність, але додатково отримує нову поведінку або модифікації.



Тепер, викликаючи complicated, ми побачимо у консолі, з якими аргументами її викликали і що вона повернула. При цьому, код самої complicated жодним чином не змінився і спосіб роботи з нею також.



Викликається функція: complicated: 2, 3
Функція complicated завершила виконання: 5
5



Проте такий код не занадто легкий для читання і досить об'ємний. Крім того, в коді легко пропустити рядок complicated = logger(complicated) і не занадто просто зрозуміти, звідки виходитиме доданий до complicated функціонал.



Щоб спростити застосування цього шаблону проектування, в Python є спеціальний синтаксис декоратора. Декоратори використовуються з синтаксисом @, що робить їх застосування простим та елегантним. Точно той самий код, який робить в точності те саме, можна записати у вигляді:



def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))



Функція logger є декоратором. Вона приймає функцію func і повертає нову функцію inner. Функція inner виконує додаткові дії (логування) до і після виконання func. При оголошенні функції complicated, ми використовуємо @logger, щоб застосувати декоратор. Тепер при кожному виклику complicated будуть виконуватися додаткові дії логування. Тепер у коді явно видно, що complicated була задекорована logger у тому самому місці, де complicated була оголошена.



Декоратори широко використовуються для різних цілей. Основні застосування це:

Логування - запис інформації про виклики функцій для забезпечення прозорості та відстеження.
Перевірка доступу - перевірка прав користувача перед виконанням функції, щоб контролювати доступ.
Кешування - збереження результатів функції для підвищення ефективності та скорочення часу виконання.
Перевірка аргументів - аналіз та модифікація аргументів перед їх передачею функції для забезпечення правильності виклику.


В майбутньому ми побачимо, що в веб-розробці декоратори стануть нашими незмінними помічниками.



Дуже важливо при створенні декораторів використовувати модуль functools, це необхідно для збереження метаданих оригінальної функції, яку ми декоруємо. Функція functools.wraps допомагає в цьому, зберігаючи інформацію про оригінальну функцію, як-от ім'я функції та документацію.



✂️ Цей код можна запустити!

from functools import wraps

def logger(func):
    @wraps(func)
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
print(complicated.__name__)



У цьому прикладі functools.wraps(func) застосовується до внутрішньої функції inner. Вона "копіює" метадані (ім'я функції, документацію тощо) від func до inner. Завдяки цьому, коли ми викликаємо print(complicated.__name__), ми отримуємо метадані оригінальної функції complicated, а не функції inner з декоратору logger.



Виведення:

Викликається функція: complicated: 2, 3
Функція complicated завершила виконання: 5
5
complicated



Це важливо для збереження очікуваної функціональності декорованої функції, особливо коли працюєте з декораторами у більш складних програмах або бібліотеках. Використання functools.wraps допомагає уникнути плутанини, пов'язаної з втратою метаданих оригінальної функції.