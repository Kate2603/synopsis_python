Серіалізація об'єктів Python за допомогою JSON

JSON, або JavaScript Object Notation, є текстовим форматом для представлення структурованих 
даних на основі синтаксису об'єктів мови програмування JavaScript.

Хоча він був розроблений для JavaScript, його легко читають і генерують багато мов програмування, 
що робить JSON дуже популярним для обміну даними між клієнтами та серверами, веб-застосунками. 
Він широко використовується для зберігання конфігурацій, серіалізації даних в файлових системах 
та як формат обміну даними між різними мовами програмування, завдяки його простоті та підтримці 
багатьма бібліотеками.

JSON пропонує просту і зрозумілу структуру. Він представляє дані як набір ключ-значення, де 
ключі є рядками, а значення можуть бути рядками, числами, масивами, логічними значеннями або 
навіть іншими об'єктами. Це дозволяє легко представляти складні структури даних, такі як списки, 
словники та ієрархічні дерева.

Головна перевага JSON полягає в тому, що він дозволяє представляти дані у форматі, який є легким 
для людини, щоб читати та писати його навіть вручну.

Синтаксис JSON базується на двох структурних елементах: об'єкти та масиви.

У JSON, об'єкти представляються у вигляді пар "ключ-значення" і огортаються у фігурні дужки {}. 
Ключі мають бути рядками (текстом у подвійних лапках), а значення можуть бути рядками, числами, 
масивами, логічними значеннями, іншими об'єктами або навіть значенням null (це значення None для 
Python). Кожна пара "ключ-значення" відділяється комою.

Наприклад:

{
  "name": "Gupalo Vasyl",
  "age": 30,
  "isStudent": true
}

Тут ми бачимо об'єкт з трьома полями: ім'я name, вік age і статус студента isStudent. Не забуваємо, 
що JSON прийшов до нас з JavaScript і логічні значення там з маленької літери: true та false. А так 
все досить схоже на наш словник.

Масиви в JSON представляються послідовністю значень, огорнутих у квадратні дужки []. Значення в 
масиві теж можуть бути рядками, числами, об'єктами, іншими масивами, логічними значеннями або null, 
і вони відділяються одне від одного комами.

Наприклад:

["apple", "banana", "cherry"]

Це масив з трьома рядковими елементами, які представляють назви фруктів. Фактично це наш список 
з рядками.

Python підтримує формат JSON та в стандартному постачанні включає в себе пакет json, в якому є 
все необхідне для роботи. Ця бібліотека дозволяє легко серіалізувати об'єкти Python у формат JSON 
та десеріалізувати рядки JSON назад у Python об'єкти. Розглянемо детально, як це працює.

Серіалізація (або "запис") перетворює об'єкти Python у рядок у форматі JSON. Це виконується за 
допомогою методу json.dumps() для перетворення об'єктів у рядок JSON.

Метод dumps запаковує в byte-рядок об'єкт, loads розпаковує (десеріалізує) з byte-рядка в об'єкт. 
Ці методи потрібні, коли ми хочемо контролювати, що робити з byte представленням, наприклад, 
відправити його мережею або прийняти з мережі.

import json

some_data = {
    "key": "value",
    2: [1, 2, 3],
    "my_tuple": (5, 6),
    "my_dict": {"key": "value"},
}

json_string = json.dumps(some_data)
print(json_string)
unpacked_some_data = json.loads(json_string)
print(unpacked_some_data)

Виведення:

{"key": "value", "2": [1, 2, 3], "my_tuple": [5, 6], "my_dict": {"key": "value"}}
{'key': 'value', '2': [1, 2, 3], 'my_tuple': [5, 6], 'my_dict': {'key': 'value'}}

В цьому прикладі запакований в json_string словник some_data розпакований в unpacked_some_data . 
Можна побачити, що unpacked_some_data не дорівнює some_data, і ми не отримали той самий об'єкт. 
Хоча JSON і Python мають схожу структуру даних, є деякі відмінності. Як бачимо, JSON не розрізняє 
кортежі та списки, обидва типи в Python будуть конвертовані у масиви JSON. Окрім того ключ ціле 
число 2 був неявно перетворений на рядок '2'.

Кодування об’єктів Python у формат JSON відбувається за наступними правилами:

Модуль json перетворює dict в об’єкти JSON,
Список і кортеж перетворюються в масив JSON.
Рядок Python перетворюється на рядок JSON.
Цілі числа та дійсні числа перетворюються на числа JSON.
Логічне значення True перетворюється на константу JSON true.
Логічне значення False перетворюється на константу JSON false.
None перетворюється на константу JSON null.

Насправді для вирішення цих та інших специфічних задач, бібліотека json дозволяє використовувати 
додаткові параметри default та object_hook для нестандартної серіалізації та десеріалізації. 
Але ми не будемо акцентувати увагу на цих специфічних задачах, а розглянемо більш актуальну 
роботу з файлами.

Серіалізація об'єкта Python у рядок формату JSON виконується за допомогою методу json.dump(), 
якщо потрібно записати JSON безпосередньо у файл.

import json

# Python об'єкт (словник)
data = {"name": "Gupalo Vasyl", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f)

Після виконання коду, в тій же директорії де знаходиться скрипт, ми повинні отримати файл 
data.json з наступним вмістом:

{"name": "Gupalo Vasyl", "age": 30, "isStudent": true}

Десеріалізація перетворює рядок у форматі JSON назад у відповідні об'єкти Python. Це 
виконується за допомогою методу json.load(), якщо JSON читається безпосередньо з файлу.

import json

# Десеріалізація з файлу
with open("data.json", "r", encoding="utf-8") as f:
    data_from_file = json.load(f)
    print(data_from_file)

Виведення:

{'name': 'Gupalo Vasyl', 'age': 30, 'isStudent': True}

В принципі немає ніякої складності з допомогою бібліотеки json виконувати гнучке 
перетворення між форматами, адаптуючи серіалізацію та десеріалізацію під конкретні 
потреби нашої програми.

Проблема може виникнути тільки при записі у файл JSON кирилиці або будь-яких інших 
не ASCII символів. Тому важливо забезпечити правильне кодування символів, щоб уникнути 
проблем з читанням файлу та його сумісністю. Python за замовчуванням використовує 
кодування UTF-8, яке підтримує кирилицю, але при записі в JSON нам необхідно вказати 
додаткові параметри для забезпечення коректного відображення символів. По що мова? 
Глянемо наступний приклад.

import json

# Python об'єкт (словник)
data = {"name": "Гупало Василь", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f)

Тут в словнику data, як значення для ключа name ми маємо рядок "Гупало Василь", який 
записаний символами кирилиці. Якщо ми заглянемо в файл data.json то побачимо наступне:

{
  "name": "\\u0413\\u0443\\u043f\\u0430\\u043b\\u043e \\u0412\\u0430\\u0441\\u0438\\u043b\\u044c",
  "age": 30,
  "isStudent": true
}

Як бачимо замість рядка "Гупало Василь" в нас набір Unicode escape-послідовностей. 
Кожна escape-послідовність починається з \u , за яким слідує чотири шістнадцяткових 
цифр, які представляють символ у Unicode.

Ось як можна це виправити та записати дані в файл JSON, використовуючи кирилицю:

import json

# Python об'єкт (словник)
data = {"name": "Гупало Василь", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

Ми використали два важливих параметри json.dump функції:

ensure_ascii=False гарантує, що символи кирилиці будуть записані як є, без перетворення 
в їхні Unicode escape-послідовності.
indent=4 забезпечує форматування виведення, роблячи JSON файл легшим для читання людиною 
за допомогою відступів.

Тепер файл data.json матиме наступний вигляд:

{
    "name": "Гупало Василь",
    "age": 30,
    "isStudent": true
}

Десеріалізація при цьому виконується, як і раніше.