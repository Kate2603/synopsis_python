Створення копій об'єктів в Python

Створення копій об'єктів у Python може виявитися нетривіальним завданням, залежно від того, чи 
потрібна вам поверхнева (shallow) або глибока (deep) копія, а також від складності структури 
даних об'єкта.

Python намагається заощаджувати пам'ять і не копіювати дані з однієї області пам'яті в іншу. 
Натомість інтерпретатор створює нове посилання, це ще один псевдонім, на реальний об'єкт, 
замість копіювання вмісту. Така поведінка може бути небажаною, розглянемо наприклад:

my_list = [1, 2, 3]
copy_list = my_list
copy_list.append(4)
print(my_list)

Виведення:

[1, 2, 3, 4]

Виходить, що copy_list — це просто ще одне ім'я для того самого списку my_list і, змінюючи 
copy_list, ми змінюємо й my_list. Це неочевидно і може збивати з пантелику.

Така поведінка може призводити до помилок, коли справа стосується типів, словників, списків, 
класів користувача, що змінюються.

Розглянемо приклад де ми передаємо список в середину функції, а вона його змінює:

my_list = [1, 2, 3]

def square_list(x: list):
    for i, el in enumerate(x):
        x[i] = el**2
    return x

new_list = square_list(my_list)
print(new_list)
print(my_list)

Виведення:

[1, 4, 9]
[1, 4, 9]

Як бачимо список my_list зазнав змін, і можливо це зовсім небажана поведінка. У прикладі функція 
square_list приймає список x як аргумент і модифікує його, підносячи кожен елемент до квадрату. 
Виходить, що функція змінює вхідний список без створення нового списку. Тому коли ми передали 
my_list в square_list, оригінальний список my_list змінюється.

Якщо нам потрібно зберегти оригінальний список my_list без змін і створити новий список з 
квадратами елементів, то слід створити копію списку перед його зміною або змінити функцію, 
щоб вона повертала новий список з квадратами елементів, замість зміни вхідного списку. Наприклад:

my_list = [1, 2, 3]

def square_list(x: list):
    return [el**2 for el in x]

new_list = square_list(my_list)
print(new_list)
print(my_list)

Виведення:

[1, 4, 9]
[1, 2, 3]

Як бачимо, оригінальний список my_list тепер залишається без змін.

Для списків та словників можна скористатися явним копіюванням:

my_list = [1, 2, 3]
copy_list = my_list[:]
copy_list.append(4)
print(my_list, copy_list)

my_dict = {1: "a"}
copy_dict = {**my_dict}
copy_dict["new_key"] = "new_value"
print(my_dict, copy_dict)

Інструкція copy_list = my_list[:] створює новий список copy_list, який є поверхневою копією 
my_list. Модифікація copy_list, як додавання елемента 4 не впливає тепер на список my_list. 
При створені словника copy_dict = {**my_dict} використовується синтаксис розпакування 
словника **, щоб створити новий словник copy_dict, який є копією my_dict.

Тепер любі модифікації copy_dict, як наприклад додавання пари ключ-значення "new_key": "new_value" 
не впливають на початковий словник my_dict.

Тому виведення буде:

[1, 2, 3] [1, 2, 3, 4]
{1: 'a'} {1: 'a', 'new_key': 'new_value'}

Обидва наші приклади ілюструють як через зріз для списків або розпакування для словників 
отримати новий, незалежний об'єкт. Але з об’єктами класів та типами користувача так легко, 
це не зробиш. Щоб вирішити цю проблему, у Python є механізм копіювання — це функції із пакету copy.